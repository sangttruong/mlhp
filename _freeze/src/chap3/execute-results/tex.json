{
  "hash": "c74b5edd5243faa71701f3e5426b1710",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Learning\nformat: html\nfilters:\n  - pyodide\nexecute:\n  engine: pyodide\n  pyodide:\n    auto: true\n\n---\n\n\n\n\n\n\nDesigning a good utility function (or reward function) by hand for a complex AI or robotics task is notoriously difficult and error-prone. Instead of manually specifying what is “good” behavior, we can learn a utility function from human preferences. In this chapter, we explore how an agent can infer a human’s underlying utility function (their preferences or reward criteria) from various forms of feedback. We discuss both supervised learning and Bayesian approaches to utility learning, and examine techniques motivated by robotics—learning from demonstrations, physical corrections, trajectory evaluations, and pairwise comparisons. Throughout, we include mathematical formulations and code examples to illustrate the learning process.\n\n## The Supervised Learning Problem\n\nSupervised learning approaches treat human feedback as labeled data to directly fit a utility function. The core idea is to assume there exists a true utility function $u^*(x)$ (over states, outcomes, or trajectories $x$) that explains a human’s choices. We then choose a parameterized model $u_\\theta(x)$ and adjust $\\theta$ so that $u_\\theta$ agrees with the human-provided preferences.\n\nA common feedback format is pairwise comparisons: the human is shown two options (outcomes or trajectories) $A$ and $B$ and indicates which is preferred. We can model the probability that the human prefers $A$ over $B$ using a logistic or Bradley–Terry model:\n\n$$\nP(A \\succ B \\mid u_\\theta) \\;=\\; \\sigma\\!\\Big(u_\\theta(A) - u_\\theta(B)\\Big)\\,,\n$$\n\nwhere $\\sigma(z)=\\frac{1}{1+e^{-z}}$ is the sigmoid function. This implies the human is more likely to prefer $A$ if $u_\\theta(A)$ is much larger than $u_\\theta(B)$.\n\nAt the heart of learning from human preferences lies a latent utility function — a function that assigns numerical value to states, trajectories, or outcomes according to a human’s (possibly unspoken) preferences. The goal of a learning algorithm is to infer this function from observed feedback, which may come in the form of demonstrations, ratings, rankings, or pairwise comparisons. But how exactly do we represent and update our belief about this hidden utility function?\n\nTwo major paradigms in statistical learning provide different answers: point estimation and posterior estimation.\n\nIn point estimation, we seek a single \"best guess\" for the utility function — typically a function $u_\\theta(x)$ from a parameterized family (e.g. linear models, neural nets), with parameters $\\theta \\in \\mathbb{R}^d$. Given data $\\mathcal{D}$ from human feedback (e.g. preferences), we choose the parameter $\\hat{\\theta}$ that best explains the observed behavior. Formally:\n\n$$\n\\hat{\\theta} = \\arg\\max_\\theta \\; p(\\mathcal{D} \\mid \\theta)\n$$\n\nThis is maximum likelihood estimation (MLE): we pick the parameters that make the observed data most probable under our model. Once $\\hat{\\theta}$ is selected, we treat $u_{\\hat{\\theta}}$ as the agent’s utility function, and optimize or sample behavior accordingly. This approach is straightforward and computationally efficient. It is the foundation of most supervised learning methods (like logistic regression or deep learning), and it provides a natural interpretation: we’re directly finding the utility function that agrees with the human feedback. However, it discards uncertainty: it assumes the data is sufficient to pin down a single utility function, which may not be true in practice.\n\nIn contrast, posterior estimation takes a fully Bayesian view. Instead of committing to one estimate, we maintain a distribution over utility functions. That is, we place a prior $p(\\theta)$ over parameters (or over functions $u$ more generally), and update this to a posterior after observing data $\\mathcal{D}$:\n\n$$\np(\\theta \\mid \\mathcal{D}) \\;=\\; \\frac{p(\\mathcal{D} \\mid \\theta)\\, p(\\theta)}{p(\\mathcal{D})}\n$$\n\nThis posterior expresses our uncertainty over which utility functions are compatible with the human feedback. From this distribution, we can make predictions (e.g., using the posterior mean utility), quantify confidence, or even actively select new queries to reduce uncertainty (active learning). For instance, if we model utilities with a Gaussian Process (GP), then the posterior over $u(x)$ is also a GP after observing comparisons or evaluations. If we use a neural network for $u_\\theta(x)$, we can approximate the posterior with ensembles, variational inference, or MCMC. Posterior estimation is especially valuable when human feedback is sparse, noisy, or ambiguous — as is often the case in real-world preference learning. It allows the agent to reason about what it doesn’t know and to take cautious or exploratory actions accordingly.\n\nThe next two sections instantiate these two perspectives. In Section 4.1, we explore point estimation via supervised learning — treating preference data as labeled examples and fitting a utility model. In Section 4.2, we shift to posterior estimation with Bayesian methods like Gaussian processes and Bayesian neural networks, which model both our current estimate and the uncertainty around it.\n\n## Point Estimation via Maximum Likelihood\nGiven a dataset of comparisons $D=\\{(A_i, B_i, y_i)\\}$ (with $y_i=1$ if $A_i$ was preferred and $0$ if $B_i$ was preferred), we can fit $\\theta$ by maximizing the likelihood of the human’s choices. Equivalently, we minimize a binary cross-entropy loss:\n\n$$\n\\mathcal{L}(\\theta) = -\\sum_{i} \\Big[\\,y_i \\log \\sigma(u_\\theta(A_i)\\!-\\!u_\\theta(B_i)) + (1-y_i)\\log(1-\\sigma(u_\\theta(A_i)\\!-\\!u_\\theta(B_i)))\\Big]\\,,\n$$\n\noften with a regularization term to prevent overfitting. This is a straightforward supervised learning problem – essentially logistic regression – on pairwise difference features.\n\nExample: Suppose a human’s utility for an outcome can be described by a quadratic function (unknown to the learning algorithm). We collect some pairwise preferences and then train a utility model $u_\\theta(x)$ to predict those preferences. The code below simulates this scenario:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\n\n# True utility function (unknown to learner), e.g. u*(x) = -(x-5)^2 + constant \ndef true_utility(x):\n    return -(x-5)**2  # (peak at x=5)\n\n# Generate synthetic pairwise preference data\nnp.random.seed(42)\nn_pairs = 20\nX1 = np.random.uniform(0, 10, size=n_pairs)  # 20 random x-values\nX2 = np.random.uniform(0, 10, size=n_pairs)  # 20 more random x-values\n# Determine preferences according to true utility\nprefs = (true_utility(X1) > true_utility(X2)).astype(int)  # 1 if X1 preferred, else 0\n\n# Parametric model for utility: u_theta(x) = w0 + w1*x + w2*x^2  (quadratic form)\n# Initialize weights\nw = np.zeros(3)\nlr = 0.01       # learning rate\nreg = 1e-3      # L2 regularization strength\nfor epoch in range(1000):\n    # Compute predictions via logistic model\n    util_diff = (w[0] + w[1]*X1 + w[2]*X1**2) - (w[0] + w[1]*X2 + w[2]*X2**2)\n    pred = 1 / (1 + np.exp(-util_diff))      # σ(w·(phi(X1)-phi(X2)))\n    # Gradient of cross-entropy loss\n    grad = np.array([0.0, 0.0, 0.0])\n    error = pred - prefs  # (sigma - y)\n    # Features for X1 and X2\n    phi1 = np.vstack([np.ones(n_pairs), X1, X1**2]).T\n    phi2 = np.vstack([np.ones(n_pairs), X2, X2**2]).T\n    phi_diff = phi1 - phi2\n    # Gradient: derivative of loss w.rt w = (sigma - y)*φ_diff (averaged) + reg\n    grad = phi_diff.T.dot(error) / n_pairs + reg * w\n    # Update weights\n    w -= lr * grad\n\nprint(\"Learned weights:\", w)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLearned weights: [ 0.          2.74417195 -0.22129969]\n```\n:::\n:::\n\n\nAfter training, we can compare the learned utility function $u_\\theta(x)$ to the true utility $u^*(x)$. Below we plot the two functions:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n\n# Plot true vs learned utility curves\nxs = np.linspace(0, 10, 200)\ntrue_vals = true_utility(xs)\nlearned_vals = w[0] + w[1]*xs + w[2]*xs**2\n\nplt.figure(figsize=(6,4))\nplt.plot(xs, true_vals, label=\"True Utility\", linewidth=3)\nplt.plot(xs, learned_vals, label=\"Learned Utility\", linestyle=\"--\", linewidth=3)\nplt.xlabel(\"State x\")\nplt.ylabel(\"Utility\")\nplt.title(\"True vs. Learned Utility Function\")\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](chap3_files/figure-pdf/cell-3-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nThe learned curve closely matches the true utility up to an arbitrary scaling factor (utility is only defined up to affine transform when inferred from comparisons). The algorithm successfully recovered a utility function that orders states almost the same as the true utility $u^*(x)$. In general, learning from comparisons can infer the *relative* utility of options (which item is preferred), although the absolute scale of $u_\\theta$ is unidentifiable without further assumptions. Supervised learning on preferences has been widely used for ranking problems and preference-based reward learning.\n\nIn standard preference learning, we often learn a utility function and then use it to define a policy. However, in some settings—especially those involving large models like language models—it is more effective to directly learn a policy that aligns with human preferences, bypassing the intermediate reward model. One such method is Direct Preference Optimization (DPO), which offers a simple, stable way to align a policy to preference data through supervised learning.\n\nTo understand DPO, consider the following setting:\n\n- We are given a reference policy $\\pi_{\\text{ref}}$, such as a pre-trained language model.\n- We want to learn a new policy $\\pi_\\theta$ that improves upon $\\pi_{\\text{ref}}$ by better reflecting human preferences.\n- Our data consists of pairwise comparisons: for each prompt $x$, a human expresses a preference between two outputs $y_+ \\succ y_-$, where $y_+$ is the preferred response.\n\nRather than learning an explicit reward function $R(x, y)$ and using it to optimize the policy via reinforcement learning, DPO treats this as a classification problem: we want to encourage the policy to assign higher likelihood to the preferred response.\n\nTo formalize this, we define a preference score:\n$$\ns_\\theta(x, y_+, y_-) = \\log \\pi_\\theta(y_+ \\mid x) - \\log \\pi_\\theta(y_- \\mid x)\n$$\nThis is the difference in log-likelihood between the preferred and dispreferred outputs. We can then define the DPO loss as a logistic regression objective:\n$$\n\\mathcal{L}_{\\text{DPO}}(\\theta) = -\\log \\sigma\\left(s_\\theta(x, y_+, y_-)\\right)\n$$\nwhere $\\sigma(z) = \\frac{1}{1 + e^{-z}}$ is the sigmoid function.\n\nThis loss encourages $\\pi_\\theta$ to assign greater probability mass to $y_+$ than $y_-$, pushing the policy toward outputs that align with human preferences. Because this is a differentiable, supervised loss, it can be optimized with standard gradient-based techniques, without needing to sample from the environment or estimate advantages, as in traditional RL.\n\nAlthough DPO does not explicitly define or optimize a reward function, we can interpret it as doing so implicitly. Suppose we define a reward function:\n$$\nR_\\theta(y \\mid x) = \\log \\pi_\\theta(y \\mid x) - \\log \\pi_{\\text{ref}}(y \\mid x)\n$$\nThis reward encourages $\\pi_\\theta$ to move away from $\\pi_{\\text{ref}}$ in directions that increase the probability of preferred outputs. Under this formulation, the DPO objective can be interpreted as optimizing this reward difference directly from preferences.\n\nTo understand why this implicit reward leads to a stable and interpretable policy, we can connect DPO to the principle of maximum entropy. This principle says that, among all distributions that satisfy certain constraints (e.g., achieving a particular expected reward), we should prefer the one with maximum entropy—that is, the most uncertain or uncommitted distribution consistent with our knowledge.\n\nFormally, consider the space $\\mathcal{P}$ of distributions over responses $y$, and a reward function $R(y)$. The maximum entropy distribution that satisfies a reward constraint is the solution to:\n\n$$\np^*(y) = \\arg\\max_{p \\in \\mathcal{P}} H(p) \\quad \\text{subject to} \\quad \\mathbb{E}_p[R(y)] \\geq \\rho\n$$\n\nThe solution to this constrained optimization problem is a Boltzmann distribution:\n$$\np^*(y) \\propto \\exp\\left(\\frac{R(y)}{\\tau}\\right)\n$$\nfor some temperature $\\tau > 0$, where $\\tau$ controls how deterministic the distribution is. As $\\tau \\to 0$, the distribution concentrates on the highest-reward outputs; as $\\tau \\to \\infty$, it becomes uniform.\n\nNow suppose our reference policy $\\pi_{\\text{ref}}(y \\mid x)$ already represents a reasonable starting point. Then the optimal policy $\\pi_\\theta$ can be viewed as a reward-weighted version of this reference policy:\n\n$$\n\\pi_\\theta(y \\mid x) \\propto \\pi_{\\text{ref}}(y \\mid x) \\cdot \\exp\\left(R_\\theta(y \\mid x)\\right)\n$$\n\nThis form ensures that $\\pi_\\theta$ remains close to $\\pi_{\\text{ref}}$ (via the KL term), while still assigning more mass to high-reward (preferred) outputs. Importantly, this form arises naturally from maximum entropy inference when the reference distribution is used as a baseline.\n\nDPO thus combines reward maximization with entropy regularization, encouraging the learned policy to prefer outcomes favored by human feedback while preserving diversity and stability. It sidesteps the challenges of explicitly learning a reward model or tuning complex RL pipelines, offering a direct and scalable method for preference-based alignment.\n\nIn practice, DPO has been shown to achieve similar or better alignment performance compared to reinforcement learning from human feedback (RLHF) while being more stable and easier to implement. It avoids the need to sample from the model during training or tune delicate hyperparameters of RL. Conceptually, DPO demonstrates that if we structure our utility model cleverly (here, as the log-ratio of policy and reference), we can extract an optimal policy in closed-form and learn utilities via supervised learning.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nfrom scipy.special import logsumexp\n\n# --- Setup: 1D input x, discrete actions y ---\nnp.random.seed(0)\nx = 5.0  # fixed input\nY = np.linspace(-4, 4, 100)  # discrete action space\nn_actions = len(Y)\n\n# --- True reward function (unknown to learner) ---\ndef true_reward(x, y):\n    return -((y - np.sin(x))**2)  # reward peak near y = sin(x)\n\nR_true = true_reward(x, Y)\n\n# --- Reference policy: fixed Gaussian-like distribution ---\ndef ref_policy(y):\n    logits = -0.5 * (y / 2.0)**2  # log probs of N(0, 2^2)\n    return np.exp(logits - logsumexp(logits))\n\npi_ref = ref_policy(Y)\n\n# --- Preference data from reward samples ---\ndef sample_preference(x, Y, R_fn, temperature=1.0):\n    logits = R_fn(x, Y) / temperature\n    probs = np.exp(logits - logsumexp(logits))\n    sampled = np.random.choice(len(Y), size=2, replace=False, p=probs)\n    y_plus, y_minus = sampled if R_fn(x, Y[sampled[0]]) > R_fn(x, Y[sampled[1]]) else sampled[::-1]\n    return y_plus, y_minus\n\nn_pairs = 100\npair_indices = [sample_preference(x, Y, true_reward) for _ in range(n_pairs)]\n\n# --- DPO loss and gradient ---\ndef dpo_loss_and_grad(theta, y_pos_idx, y_neg_idx, pi_ref):\n    logits = theta + np.log(pi_ref + 1e-8)\n    logp_pos = logits[y_pos_idx] - logsumexp(logits)\n    logp_neg = logits[y_neg_idx] - logsumexp(logits)\n    s = logp_pos - logp_neg\n    sigma = 1 / (1 + np.exp(-s))\n    loss = -np.log(sigma + 1e-8)\n    softmax = np.exp(logits - logsumexp(logits))\n    grad = - (1 - sigma) * (np.eye(n_actions)[y_pos_idx] - np.eye(n_actions)[y_neg_idx]) + sigma * softmax\n    return loss, grad\n\n# --- Training loop with history tracking ---\ntheta = np.zeros(n_actions)\nlr = 0.05\nn_steps = 100\nhistory = []\n\nfor step in range(n_steps):\n    total_grad = np.zeros_like(theta)\n    for y_pos_idx, y_neg_idx in pair_indices:\n        _, grad = dpo_loss_and_grad(theta, y_pos_idx, y_neg_idx, pi_ref)\n        total_grad += grad\n    theta -= lr * total_grad / n_pairs\n    logits_snapshot = theta + np.log(pi_ref + 1e-8)\n    pi_snapshot = np.exp(logits_snapshot - logsumexp(logits_snapshot))\n    history.append(pi_snapshot)\n\n# --- Animation setup ---\nfig, ax = plt.subplots(figsize=(7, 4))\nline_true, = ax.plot(Y, R_true, 'k--', label='True Reward')\nline_ref, = ax.plot(Y, pi_ref, 'g-', label='Reference Policy')\nline_learned, = ax.plot([], [], 'b-', label='Learned Policy')\n\n# Add preference pair indicators\npref_lines = [ax.axvline(Y[idx], color='blue', linestyle=':', alpha=0.3) for idx, _ in pair_indices]\npref_lines += [ax.axvline(Y[idx], color='red', linestyle=':', alpha=0.3) for _, idx in pair_indices]\n\nax.set_ylim(-0.025, 0.025)\nax.set_title(\"DPO Policy Evolution\")\nax.set_ylabel(\"Probability\")\nax.set_xlabel(\"y\")\nax.legend()\n\ndef update(frame):\n    pi_snapshot = history[frame]\n    line_learned.set_data(Y, pi_snapshot)\n    ax.set_title(f\"DPO Policy Evolution (Step {frame + 1})\")\n    return [line_learned]\n\nfrom IPython.display import HTML\nfrom matplotlib import rc\nrc('animation', html='jshtml')\n\nani = animation.FuncAnimation(fig, update, frames=n_steps, interval=100, blit=True)\nHTML(ani.to_jshtml())\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n<IPython.core.display.HTML object>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](chap3_files/figure-pdf/cell-4-output-2.pdf){fig-pos='H'}\n:::\n:::\n\n\nThe pairwise logistic approach can be extended to other feedback types. If humans provide numeric *ratings* or *scores* for options, one can treat utility learning as a regression problem: fit $u_\\theta(x)$ to predict those scores (perhaps with a suitable bounded output or ordinal regression if scores are ordinal). If humans rank multiple options at once, algorithms like *RankNet* or *RankSVM* generalize the pairwise approach to listwise ranking losses. All these methods boil down to defining a loss that penalizes disagreements between the predicted utility order and the human-provided preferences, then optimizing $\\theta$ to minimize that loss.\n\nSupervised learning of utility is powerful due to its simplicity, but it typically provides point estimates of $u_\\theta$. Next, we consider Bayesian approaches that maintain uncertainty over the utility function.\n\n## Posterior Estimation\n\nWhen feedback data is sparse, as is common in preference learning, it can be advantageous to model uncertainty over the utility function. Bayesian approaches place a prior on the utility function and update a posterior as human feedback is observed. This yields not only a best-guess utility function but also a measure of confidence or uncertainty, which is valuable for active learning (deciding which queries to ask next) and for safety (knowing when the learned reward might be wrong).\n\nA popular Bayesian approach assumes that the human’s utility function can be modeled as a Gaussian Process (GP) – a distribution over functions. A GP prior is defined by a mean function (often taken to be 0 for convenience) and a kernel (covariance function) $k(x,x')$ which encodes assumptions about the smoothness or structure of the utility function. For example, one might assume $u(x)$ is a smooth function of state, and choose a radial basis function (RBF) kernel $k(x,x') = \\sigma_f^2 \\exp(-\\|x-x'\\|^2/(2\\ell^2))$ with some length-scale $\\ell$.\n\nAfter observing some preference data, Bayes’ rule gives a posterior over the function $u(x)$. In the case of pairwise comparisons, the likelihood of a comparison $(A \\succ B)$ given an underlying utility function $u$ can be modeled via the same logistic function: $P(A \\succ B \\mid u) = \\sigma(u(A)-u(B))$. Combining this likelihood with the GP prior is analytically intractable (due to the non-Gaussian logistic likelihood), but one can use approximation techniques (Laplace approximation or MCMC) to obtain a posterior GP. The result is a *Gaussian process preference model* that can predict the utility of any new option with an uncertainty interval.\n\nIf we have direct evaluations of utility (e.g., the human provides a numeric reward for some states), the GP inference is simpler – it reduces to standard GP regression. However, in many real-world scenarios, humans are better at making relative judgments than assigning absolute utility values. This change in feedback type transforms the inference problem fundamentally. Instead of having a Gaussian likelihood (as in standard GP regression), we now have a non-Gaussian likelihood, typically modeled using a probit or logistic function. The observed data no longer provide direct samples of the latent utility function, but instead impose constraints on the *relative* ordering of latent values.\n\nDue to this non-Gaussian likelihood, exact Bayesian inference is no longer tractable: the posterior over the latent utility function given the pairwise data does not have a closed-form expression. The GP prior is still Gaussian, but the posterior becomes non-Gaussian and multi-modal, particularly as the number of comparisons grows.\n\nTo address this, we must turn to approximate inference methods. One common and computationally efficient choice is the Laplace approximation, which approximates the true posterior with a Gaussian centered at the maximum a posteriori (MAP) estimate. This involves:\n1. Finding the mode of the posterior (i.e., the most probable utility values given the data),\n2. Approximating the curvature of the log-posterior around this mode using the Hessian (second derivative),\n3. Using this local curvature to construct a Gaussian approximation.\n\nWhile not exact, this method works well in practice, especially when the posterior is unimodal and the number of comparison pairs is moderate. Other alternatives such as variational inference or sampling-based methods (e.g., Hamiltonian Monte Carlo) can yield more accurate results but often require more complex implementation and computational resources.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\nfrom scipy.optimize import minimize\n\n# --- True latent utility function ---\ndef true_u(x):\n    return np.sin(x) + 0.1 * x\n\n# --- RBF Kernel function ---\ndef rbf_kernel(x1, x2, length_scale=0.8, sigma_f=1.0):\n    x1, x2 = np.atleast_2d(x1).T, np.atleast_2d(x2).T\n    sqdist = (x1 - x2.T) ** 2\n    return sigma_f**2 * np.exp(-0.5 * sqdist / length_scale**2)\n\n# --- Generate synthetic preference data ---\nnp.random.seed(42)\nnum_pairs = 10\nX_candidates = np.linspace(0, 10, 100)\ntrue_utilities = true_u(X_candidates)\n\n# Sample preference pairs\nidx_pairs = np.random.choice(len(X_candidates), size=(num_pairs, 2), replace=True)\nX_pref_pairs = []\nfor i, j in idx_pairs:\n    xi, xj = X_candidates[i], X_candidates[j]\n    if true_utilities[i] > true_utilities[j]:\n        X_pref_pairs.append((xi, xj))\n    else:\n        X_pref_pairs.append((xj, xi))\nX_pref_pairs = np.array(X_pref_pairs)\n\n# --- Unique x values and indexing ---\nX_all = np.unique(X_pref_pairs.flatten())\nn = len(X_all)\nx_to_idx = {x: i for i, x in enumerate(X_all)}\n\n# --- GP prior kernel matrix ---\nlength_scale = 0.8\nsigma_f = 1.0\nsigma_noise = 1e-6\nK = rbf_kernel(X_all, X_all, length_scale, sigma_f) + sigma_noise * np.eye(n)\n\n# --- Negative log-posterior function ---\ndef neg_log_posterior(f):\n    prior_term = 0.5 * f.T @ np.linalg.solve(K, f)\n    lik_term = 0.0\n    for xi, xj in X_pref_pairs:\n        fi, fj = f[x_to_idx[xi]], f[x_to_idx[xj]]\n        delta = (fi - fj) / np.sqrt(2)\n        lik_term -= np.log(norm.cdf(delta) + 1e-6)\n    return prior_term + lik_term\n\n# --- MAP estimation of latent utilities ---\nf_init = np.zeros(n)\nres = minimize(neg_log_posterior, f_init, method=\"L-BFGS-B\")\nf_map = res.x\n\n# --- Laplace approximation: compute W (Hessian of neg log likelihood) ---\nW = np.zeros((n, n))\nfor xi, xj in X_pref_pairs:\n    i, j = x_to_idx[xi], x_to_idx[xj]\n    fi, fj = f_map[i], f_map[j]\n    delta = (fi - fj) / np.sqrt(2)\n    phi = norm.pdf(delta)\n    Phi = norm.cdf(delta) + 1e-6\n    w = (phi / Phi)**2 + delta * phi / Phi\n    w /= 2  # adjust for sqrt(2)\n    W[i, i] += w\n    W[j, j] += w\n    W[i, j] -= w\n    W[j, i] -= w\n\n# --- Posterior covariance approximation ---\nL = np.linalg.cholesky(K)\nK_inv = np.linalg.solve(L.T, np.linalg.solve(L, np.eye(n)))\nH = K_inv + W\nH_inv = np.linalg.inv(H)\n\n# --- Prediction at test points ---\nX_test = np.linspace(0, 10, 200)\nK_s = rbf_kernel(X_all, X_test, length_scale, sigma_f)\nK_ss_diag = np.diag(rbf_kernel(X_test, X_test, length_scale, sigma_f))\n\n# Posterior mean and variance\nposterior_mean = K_s.T @ K_inv @ f_map\ntemp = np.linalg.solve(H, K_s)\nposterior_var = K_ss_diag - np.sum(K_s * temp, axis=0)\nposterior_std = np.sqrt(np.maximum(posterior_var, 0))\n\n# --- Visualization ---\nplt.figure(figsize=(8, 4))\nplt.plot(X_test, true_u(X_test), 'k--', label=\"True utility\")\nplt.plot(X_test, posterior_mean, 'b-', label=\"Posterior mean\")\nplt.fill_between(X_test,\n                 posterior_mean - 1.96 * posterior_std,\n                 posterior_mean + 1.96 * posterior_std,\n                 color='blue', alpha=0.2, label=\"95% CI\")\nplt.scatter(X_all, [true_u(x) for x in X_all], c='red', marker='x', label=\"Observed x\")\nplt.title(\"GP Preference Learning (Laplace Approximation, 100 Pairs)\")\nplt.xlabel(\"x\")\nplt.ylabel(\"Utility\")\nplt.legend()\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](chap3_files/figure-pdf/cell-5-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nGaussian Process posterior for a utility function (blue mean with 95% confidence band) after observing 5 points of noisy utility data (red ×). The true utility function (black dashed) is non-trivial. The GP correctly captures the function’s value around observed regions and expresses high uncertainty in the unobserved middle region. In practice, this uncertainty could guide an algorithm to query more feedback in the region $x\\approx [4,7]$ to reduce ambiguity.\n\nGaussian processes are a flexible way to learn utility functions. They naturally handle irregular data and provide principled uncertainty estimates. GP-based preference learning has been applied to tasks like interactive Bayesian optimization, where an algorithm seeks to find the maximum of $u(x)$ by iteratively querying a human which of two options is better [@christiano2023deep].\n\nInstead of GPs, one can use Bayesian neural networks or ensemble methods to model uncertainty in $u_\\theta(x)$. For instance, a neural network can be trained on preference data, and techniques like Monte Carlo dropout or deep ensembles can provide uncertainty estimates for its predictions. These approaches scale to high-dimensional inputs (where GPs may be less practical) while still capturing epistemic uncertainty about the utility.\n\nOne principled way to capture uncertainty in Bayesian neural networks is via Markov Chain Monte Carlo (MCMC) methods, which seek to approximate the posterior distribution over model parameters given the data. In this setting, we place a prior over the neural network weights, $p(\\theta)$, and define a likelihood function based on observed preferences—typically using a probabilistic choice model such as the Bradley-Terry or probit model. Given a dataset $\\mathcal{D} = \\{(x_i, x_j) : x_i \\succ x_j\\}$, the posterior is defined as\n\n$$\np(\\theta \\mid \\mathcal{D}) \\propto p(\\mathcal{D} \\mid \\theta) \\cdot p(\\theta),\n$$\n\nwhere $p(\\mathcal{D} \\mid \\theta)$ is the likelihood of observing the pairwise comparisons under the utility function $u_\\theta(x)$, and $p(\\theta)$ is the prior over the parameters.\n\nUnlike Gaussian processes, for which posterior inference is tractable in closed form under Gaussian likelihoods, inference in BNNs with non-Gaussian likelihoods is generally intractable. This is due to the non-conjugate nature of the neural network likelihood and the high-dimensional, nonlinear structure of the weight space. As a result, approximate inference methods are required.\n\nMCMC provides a general-purpose approach to approximate sampling from the posterior. The key idea is to construct a Markov chain whose stationary distribution is the target posterior. One of the most widely used algorithms is the Metropolis-Hastings (MH) algorithm. Given a current state $\\theta_t$, a new proposal $\\theta'$ is generated from a proposal distribution $q(\\theta' \\mid \\theta_t)$, and accepted with probability\n\n$$\nA = \\min\\left(1, \\frac{p(\\mathcal{D} \\mid \\theta') \\, p(\\theta') \\, q(\\theta_t \\mid \\theta')}{p(\\mathcal{D} \\mid \\theta_t) \\, p(\\theta_t) \\, q(\\theta' \\mid \\theta_t)}\\right).\n$$\n\nWhen the proposal distribution is symmetric, i.e., $q(\\theta' \\mid \\theta_t) = q(\\theta_t \\mid \\theta')$, the acceptance probability simplifies to a ratio of posterior densities. Over time, the chain yields samples $\\theta^{(1)}, \\dots, \\theta^{(T)} \\sim p(\\theta \\mid \\mathcal{D})$, which can be used to compute posterior predictive estimates for the utility function:\n\n$$\n\\mathbb{E}[u(x)] \\approx \\frac{1}{T} \\sum_{t=1}^T u_{\\theta^{(t)}}(x),\n$$\n\nwith corresponding uncertainty estimates captured via the variance of the predictions across samples.\n\nMCMC methods are particularly appealing for preference learning because they directly quantify epistemic uncertainty in the utility function, which is crucial for downstream tasks such as decision-making, active learning, and safe exploration. Furthermore, MCMC makes no restrictive assumptions on the form of the posterior and can be used with non-convex and multi-modal distributions that arise from complex neural network architectures.\n\nHowever, MCMC also faces significant computational challenges in practice. First, the convergence of the Markov chain can be slow, especially in high-dimensional parameter spaces. Second, naive random-walk proposals (as in the basic Metropolis-Hastings algorithm) may suffer from low acceptance rates and poor mixing. More advanced MCMC methods such as Hamiltonian Monte Carlo (HMC) and No-U-Turn Sampling (NUTS) can help address these issues by using gradient information to propose more efficient moves through the parameter space.\n\nDespite these limitations, MCMC remains a valuable tool for principled Bayesian inference in preference modeling, particularly in settings where uncertainty quantification is critical and computational cost is acceptable. In lower-dimensional settings or as a pedagogical tool, even simple MH-based approaches can offer intuitive and effective approximations to the posterior over preference functions.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\n\n# --- True latent utility function ---\ndef true_u(x):\n    return np.sin(x) + 0.1 * x\n\n# --- Generate synthetic preference data ---\nnp.random.seed(0)\nX = np.linspace(0, 10, 40)\ny_true = true_u(X)\n\n# Create pairwise comparisons\npairs = []\nfor _ in range(50):\n    i, j = np.random.choice(len(X), 2, replace=False)\n    if y_true[i] > y_true[j]:\n        pairs.append((X[i], X[j], 1))  # x_i preferred over x_j\n    else:\n        pairs.append((X[j], X[i], 1))\n\n# --- Define a deep neural network: 3 hidden layers ---\ndef init_deep_params(hidden_dims=[10, 10, 10]):\n    params = {}\n    layer_dims = [1] + hidden_dims + [1]\n    for i in range(len(layer_dims) - 1):\n        W_key = f\"W{i+1}\"\n        b_key = f\"b{i+1}\"\n        params[W_key] = np.random.randn(layer_dims[i+1], layer_dims[i]) * 0.1\n        params[b_key] = np.zeros((layer_dims[i+1], 1))\n    return params\n\ndef deep_forward(x, params):\n    x = x.reshape(1, 1)\n    num_layers = len(params) // 2\n    h = x\n    for i in range(1, num_layers):\n        h = np.tanh(params[f\"W{i}\"] @ h + params[f\"b{i}\"])\n    out = params[f\"W{num_layers}\"] @ h + params[f\"b{num_layers}\"]\n    return out.squeeze()\n\ndef deep_utility(x, params):\n    return np.array([deep_forward(np.array([xi]), params) for xi in x])\n\n# --- Log likelihood (Bradley-Terry) ---\ndef deep_log_likelihood(params, pairs):\n    ll = 0.0\n    for xi, xj, _ in pairs:\n        ui = deep_forward(np.array([xi]), params)\n        uj = deep_forward(np.array([xj]), params)\n        ll += np.log(norm.cdf((ui - uj) / np.sqrt(2)) + 1e-6)\n    return ll\n\n# --- Gaussian prior on weights ---\ndef deep_log_prior(params):\n    lp = 0.0\n    for v in params.values():\n        lp -= 0.5 * np.sum(v**2)\n    return lp\n\n# --- Proposal distribution ---\ndef deep_propose(params, sigma=0.05):\n    new_params = {}\n    for k, v in params.items():\n        new_params[k] = v + np.random.randn(*v.shape) * sigma\n    return new_params\n\n# --- Metropolis-Hastings sampling ---\ndef deep_mh(init_params, pairs, num_iters=2000, burn_in=500):\n    samples = []\n    current = init_params\n    current_lp = deep_log_likelihood(current, pairs) + deep_log_prior(current)\n\n    for i in range(num_iters):\n        proposal = deep_propose(current)\n        proposal_lp = deep_log_likelihood(proposal, pairs) + deep_log_prior(proposal)\n        accept_prob = np.exp(proposal_lp - current_lp)\n        if np.random.rand() < accept_prob:\n            current = proposal\n            current_lp = proposal_lp\n        if i >= burn_in:\n            samples.append(current)\n\n    return samples\n\n# --- Run MCMC ---\ndeep_samples = deep_mh(init_deep_params(), pairs, num_iters=2000, burn_in=200)\n\n# --- Posterior predictions ---\nX_test = np.linspace(0, 10, 200)\ndeep_preds = np.array([deep_utility(X_test, s) for s in deep_samples])\ndeep_mean = deep_preds.mean(axis=0)\ndeep_std = deep_preds.std(axis=0)\n\n# --- Plot results ---\nplt.figure(figsize=(8, 4))\nplt.plot(X_test, true_u(X_test), 'k--', label='True utility')\nplt.plot(X_test, deep_mean, 'b-', label='BNN (3-layer) mean')\nplt.fill_between(X_test, deep_mean - 1.96 * deep_std, deep_mean + 1.96 * deep_std,\n                 color='blue', alpha=0.2, label='95% CI')\nplt.title(\"3-layer Bayesian Neural Network via MCMC on Preference Data\")\nplt.xlabel(\"x\")\nplt.ylabel(\"Utility\")\nplt.legend()\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](chap3_files/figure-pdf/cell-6-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nAnother Bayesian approach is Bayesian Inverse Reinforcement Learning (IRL), where a prior is placed on the parameters of a reward function and Bayes’ rule is used to update this distribution given demonstrations or preferences [@iliad2019learning]. Early work like Ramachandran & Amir (2007) treated IRL as Bayesian inference, using MCMC to sample likely reward functions consistent with demonstrations. Such methods yield a posterior over reward functions, reflecting ambiguity when multiple rewards explain the human’s behavior.\n\nIn summary, Bayesian utility learning methods acknowledge that with limited human feedback, many possible utility functions might be compatible with the data. They keep track of this ambiguity, which is crucial for making cautious decisions and for actively gathering more feedback.\n\n## Case Study: Learning from Human Feedback in Robotics {.unnumbered}\n\nThus far, we discussed preference learning in general terms. We now focus on robotics, where an agent must learn a *reward/utility function* that captures the human’s objectives for a *sequential decision-making* task. Robotics brings additional challenges: the utility often depends on a trajectory of states and actions, and feedback can come in multiple forms. We outline several key forms of human feedback for robot learning and how to learn from them:\n\n- Learning from demonstrations – inferring utility from expert demonstrations of the task.\n- Learning from physical corrections – updating utility when a human physically intervenes in the robot’s behavior.\n- Learning from trajectory evaluations – using human-provided scores or critiques of full trajectories.\n- Learning from pairwise trajectory comparisons – inferring reward from which of two trajectories a human prefers.\n\nThese are not mutually exclusive; in practice, combinations can be very powerful [@iliad2019learning]. We describe each mode and how utility functions can be derived.\n\n### Learning from Demonstrations (Inverse Reinforcement Learning) {.unnumbered}\n\nIn Learning from Demonstrations, also known as Inverse Reinforcement Learning, the human provides examples of desired behavior (e.g. teleoperating a robot to show how to perform a task). The assumption is that the demonstrator is approximately optimizing some latent reward function $R^*(s,a)$ (or utility for trajectories). IRL algorithms then search for a reward function $R_\\theta$ under which the given demonstrations $\\tau_{demo}$ have high expected return [@iliad2019learning]. \n\nOne classic approach is *Maximum Margin IRL*, which finds a reward function that makes the return of the demonstration trajectories higher than that of any other trajectories by a large margin. Another is *Maximum Entropy IRL*, which models the demonstrator as noisily optimal (Boltzmann-rational) [@iliad2019learning]. In MaxEnt IRL, the probability of a trajectory $\\tau$ under reward parameters $\\theta$ is modeled as:\n\n$$\nP(\\tau \\mid \\theta) = \\frac{\\exp\\{R_\\theta(\\tau)\\}}{\\displaystyle \\sum_{\\tau'} \\exp\\{R_\\theta(\\tau')\\}} \\,,\n$$\n\nwhere $R_\\theta(\\tau) = \\sum_{t} r_\\theta(s_t, a_t)$ is the cumulative reward of $\\tau$. The IRL algorithm then adjusts $\\theta$ to maximize the likelihood of the human demonstrations (while often using techniques to approximate the denominator, since summing over all trajectories is intractable). The end result is a reward function $R_\\theta(s,a)$ that rationalizes the demonstrations.\n\n*Key challenge:* unless demonstrations are *optimal* and cover the space well, IRL might recover an ambiguous or incorrect reward. In robotics, humans often have difficulty providing flawless demonstrations (due to hard-to-use interfaces or limited expertise) [@iliad2019learning]. For example, users teleoperating a robot arm might move jerkily or only accomplish part of the task [@iliad2019learning]. This makes sole reliance on demonstrations problematic. Nonetheless, demonstration data can provide a strong prior: it shows at least one way to succeed (or partial preferences for certain behaviors).\n\n### Learning from Preferences and Rankings of Trajectories {.unnumbered}\n\nWhen high-quality demonstrations are hard to obtain, preference queries on trajectories are a viable alternative [@iliad2019learning]. In preference-based learning for robotics, the robot (or algorithm) presents two (or more) trajectories of the task outcome, and the human chooses which one is better. Each such comparison provides a bit of information about the true underlying reward. By asking many queries, the algorithm can home in on the reward function that explains the human’s choices [@iliad2019learning].\n\nA concrete example is an agent learning to do a backflip in simulation [@christiano2023deep]. The agent initially performs random flails. The system then repeatedly shows the human *two video clips* of the agent’s behavior and asks which is closer to a proper backflip. From these comparisons, a reward model is learned that assigns higher value to behaviors more like backflips [@christiano2023deep]. The agent then uses reinforcement learning to optimize this learned reward, gradually performing better backflips. This process continues, with the human being asked comparisons on trajectories where the algorithm is most uncertain (to maximally inform the reward model) [@christiano2023deep].\n\n ([Learning from human preferences | OpenAI](https://openai.com/index/learning-from-human-preferences/)) *Framework for learning from human preferences in robotics: a reward predictor (utility function) is learned from human feedback on trajectory comparisons, and an RL algorithm uses this learned reward to improve the policy [@christiano2023deep]. The loop is iterative: as the policy improves, new queries focus on areas of uncertainty to refine the reward model.* \n\nSuch preference-based reward learning has enabled complex skills without explicitly programmed rewards [@christiano2023deep]. Notably, Christiano *et al.* (2017) showed that an agent can learn Atari game policies and robotic manipulations from a few hundred comparison queries, achieving goals that are hard to specify but easy to judge [@christiano2023deep]. Preferences are often easier for humans than demonstrations: choosing between options is simpler than generating one from scratch [@iliad2019learning]. However, preference learning can be slow if each query only yields one bit of information. Active learning and combining preferences with other feedback can greatly improve efficiency [@iliad2019learning].\n\n### Learning from Trajectory Evaluations (Critiques and Ratings) {.unnumbered}\n\nSometimes humans provide feedback in the form of *evaluative scores* or critiques on full trajectories (or partial trajectories). For example, after a robot finishes an attempt at a task, the human might give a reward signal (e.g. +1/-1, or a rating 1–5 stars, or say “too slow” vs “good job”). This is the premise of the TAMER framework (Training an Agent via Evaluative Reinforcement) and related approaches, where a human’s scalar reward signals are directly treated as the reward function for the agent in reinforcement learning.\n\nFrom a utility learning perspective, such feedback can be used to directly fit a utility model $u_\\theta$ that predicts the human’s rating for a given trajectory. For instance, if a human provides a score $H(\\tau)$ for trajectory $\\tau$, one can treat it as a training target for $u_\\theta(\\tau)$ (possibly under a regression loss). However, because humans are inconsistent and may not precisely quantify their preferences, it’s often useful to model $H(\\tau)$ as a noisy realization of the underlying utility, rather than a perfect label. A Bayesian approach could treat $H(\\tau)$ as a noisy observation of $u(\\tau)$ and update a posterior for $u$. Alternatively, classification approaches can be used (e.g. treat trajectories into “liked” vs “disliked” based on thresholded ratings).\n\nA challenge with trajectory-level feedback is *credit assignment*: the human’s single score must be attributed to the entire sequence of actions. Algorithms like COACH (Continuous cOaching of Automated Control Handlers) address this by allowing humans to give feedback at intermediate steps, thereby guiding the agent which specific part of the behavior was good or bad. In either case, learning from trajectory evaluations turns the human into a *reward function provider*, and the learning algorithm’s job is to infer the latent reward function that the human’s evaluations are trying to convey.\n\n### Learning from Physical Corrections {.unnumbered}\n\nRobots that physically collaborate with humans can receive physical corrections: the human may push the robot or otherwise intervene to adjust its behavior. Such corrections provide insight into the human’s desired utility. For example, if a household robot is carrying a fragile object too recklessly and the human physically slows it down or re-routes it, that indicates the human’s reward favors safety over speed at that moment.\n\nLearning from physical corrections can be formalized in different ways. One approach is to treat a correction as a demonstration on a small segment: the human’s intervention suggests a better action or trajectory than what the robot was doing. This can be converted into a comparison: “the trajectory after correction is preferred over the original trajectory” for that time segment. The robot can then update its reward function $\\theta$ to satisfy $R_\\theta(\\text{human-corrected behavior}) > R_\\theta(\\text{robot’s initial behavior})$. Repeated corrections yield a dataset of such pairwise preferences, focused on the states where the robot was wrong [@losey2021corrections].\n\nAnother approach is to infer the human’s intent through the sequence of corrections. Research by Losey *et al.* (2021) formalized learning from *sequences* of physical corrections, noting that each correction is not independent: a series of pushes might only make sense in aggregate [@losey2021corrections]. By analyzing the cumulative effect of multiple interventions, the algorithm can deduce the underlying objective more accurately (e.g. the human consistently steers the robot away from the table edges, implying a high negative reward for collisions). Their algorithm introduced an auxiliary reward term to capture the human’s trade-off: they will correct the robot if the immediate mistake is worth fixing relative to long-term performance [@losey2021corrections]. The conclusion was that reasoning over the sequence of corrections improved learning of the human’s objective [@losey2021corrections].\n\nPhysical corrections are intuitive for humans – we often instinctively guide others or objects when they err. For the robot, interpreting this guidance requires converting it into constraints or examples for the utility function. It is a powerful signal because it is *active*: the human is not just telling preferences but directly imparting the desired direction of change.\n\n### Combining Multiple Feedback Types {.unnumbered}\n\nEach feedback modality has strengths and weaknesses. Demonstrations provide a lot of information but can be hard to perform; preferences are easy for humans but yield information slowly; corrections are very informative locally but require physical interaction; trajectory evaluations are straightforward but coarse. Combining these modes can lead to faster and more robust reward learning [@iliad2019learning]. For example, the DemPref algorithm [@iliad2019learning] first uses demonstrations to get an initial rough reward model, then uses preference queries to refine it quickly [@iliad2019learning]. In user studies, such combined approaches learned better rewards with fewer queries than using either alone [@iliad2019learning].\n\nIn practical robot learning systems, one might start by asking for a demonstration. If the demo is suboptimal, the system can then ask preference questions on alternative attempts to clarify the true goal. During actual execution, if the human intervenes, the robot updates its reward function on the fly to avoid repeating the mistake. This *interactive reward learning* loop continues until the robot’s behavior aligns with human intent.\n\n## Summary\n\nLearning utility functions from human preferences enables value alignment: aligning an AI system’s objectives with what humans actually want, rather than what we *think* we want in abstract. We covered how supervised learning can extract utilities from comparisons or scores, and how Bayesian methods like Gaussian processes and Bayesian neural nets can capture uncertainty in our inferences. In robotics, we saw that feedback can come in many forms – demonstrations, comparisons, corrections, evaluations – each providing a unique window into the human’s utility function. By intelligently combining these signals, robots can efficiently learn complex reward functions that would be extremely difficult to hand-code.\n\nKey takeaways and best practices include:\n\n- *Use the right feedback for the problem:* If optimal examples are available, demonstrations jump-start learning. If not, pairwise preferences or scalar critiques might be easier to obtain.\n- *Model uncertainty:* Knowing what the system doesn’t know (via a Bayesian model) allows for smart query selection and avoids overconfidently optimizing the wrong objective.\n- *Iterate with the human:* Preference learning is fundamentally an interactive process. An agent can query a human in ambiguous cases and continuously refine the utility estimate [@christiano2023deep].\n- *Validate the learned utility:* Once a reward is learned, testing the robot’s policy and having humans verify or correct it is crucial. Even a few manual corrections can reveal if the learned reward misses a key aspect, allowing further refinement.\n- *Be aware of scaling and bias:* Human feedback can be noisy or biased. Techniques like DPO suggest ways to simplify learning and avoid instability, but one should monitor for issues like reward hacking or unintended solutions, intervening with additional feedback as needed.\n\nLearning from human preferences is a rich area of ongoing research. It lies at the intersection of machine learning, human-computer interaction, and ethics. As AI systems become more advanced, the importance of teaching them *our* utility functions (and not mis-specified proxies) grows. The methods discussed in this chapter are building blocks toward AI that truly understands and pursues what humans value, acquired through learning *with* humans in the loop rather than in isolation. By mastering these techniques, we move closer to AI and robots that can be trusted to make decisions aligned with human preferences and well-being. \n\n<!--\n### Reward Learning in Robotics\n\nTo help set up our basic reward learning problem, consider a user and a\nrobot. The user's preferences or goals can be represented by an internal\nreward function, R($\\xi$), which the robot needs to learn. Since the\nreward function isn't explicit, there are a variety of ways that the\nrobot can learn this reward function, which we will discuss in the next\nsection. An example method of learning a reward function from human data\nis using pairwise comparison. Consider the robot example from section\none, but now, the robot shows the human two possible trajectories\n$\\xi_A$ and $\\xi_B$ as depicted in the diagram below.\n\n![Two different trajectories taken by a robot to prompt\nuser ranking.](Figures/robots.png){#fig-reward-robot-1 width=\"70%\"}\n\nThe user is show both the trajectories above and asked to rank which one\nis better. Based on iterations of multiple trajectories and ranking, the\nrobot is able to learn the user's internal reward function. There quite\na lot of ways that models can learn a reward function from human data.\nHere's a list [@myers2021learning] of some of them:\n\n1.  Pairwise comparison: This is the method that we saw illustrated in\n    the previous example. The robot is able to learn based on a\n    comparison ranking provided by the user.\n\n2.  Expert demonstrations: Experts perform the task and the robot learns\n    the optimal reward function from these demonstrations.\n\n3.  Sub-optimal demonstrations: The robot is provided with\n    demonstrations that are not quite as good as the expert\n    demonstrations but it is still able to learn a noisy reward function\n    from the demonstrations.\n\n4.  Physical Corrections: While the robot is performing the task, at\n    each point in its trajectory (or at an arbitrary point in its\n    trajectory) its arm is corrected to a more suitable position. Based\n    on these corrections, the robot is able to learn the reward\n    function.\n\n5.  Ranking: This method is similar to pairwise comparison but involves\n    more trajectories than 2. All the trajectories may have subtle\n    differences from each other, but these differences help provide\n    insight to the model.\n\n6.  Trajectory Assessment: Given a single trajectory, the user rates how\n    close it is to optimal, typically using a ranking scale.\n\n    Each of these methods allows the robot to refine its understanding\n    of the user's reward function, but their effectiveness can vary\n    depending on the application. For instance, expert demonstrations\n    tend to produce more reliable results but may not always be feasible\n    in everyday tasks. Pairwise comparison and ranking methods offer\n    more flexibility but might require a higher number of iterations.\n\n### Direct Preference Optimization\n\nA modern method for estimating the parameters of a human preference\nmodel is direct preference optimization [@rafailov2023direct], which is\nused in the context of aligning language models to human preferences. A\nrecent approach [@christiano2023deep] first trains a reward model that\ncaptures human preferences and then uses proximal policy optimization to\ntrain a language model-based policy to reflect those learned\npreferences. Direct Preference Optimization (DPO), on the other hand,\nremoves the need for a reward model by directly using the model\nlikelihood of two outcomes (a preferred or highly-ranked sequence and an\nunpreferred or low-ranked sequence) to capture the preference\nrepresented in the data. DPO provides a simpler framework than its\nreinforcement learning approach and results in comparable performance\nwith improved stability. Furthermore, it obviates the need to train a\nreward model, instead using a language model policy and human preference\ndataset to align the policy directly to human preferences.\n\n<!--\nThrough our exploration of human preference models, we will ground ourselves in\nbuilding a health coaching system that can provide meal recommendations aligned with a user's dietary needs and preferences. Examples of scenarios which can benefit from a model of how humans make choices include:\n\n1.  **Health coaching:** Humans express their preferences every time\n    they pick lunch for consumption. Humans may have several goals\n    related to nutrition, such as weight loss and improving\n    concentration. We can learn how a given individual or set of\n    individuals prefer to eat to provide personalized recommendations to\n    help them attain their goals. This chapter will use this use case to\n    ground human preference modeling in a real-life application.\n\n2.  **Social media:** Platforms have a far greater amount of content\n    than one can consume in a lifetime, yet such products must aim to\n    maximize user engagement. To accomplish this, we can learn what\n    specific things people like to see in their feeds to optimize the\n    value they gain out of their time on social media. For example, the\n    video feed social media platform [TikTok](https://www.tiktok.com/)\n    has had viral adoption due to its notorious ability to personalize a\n    feed for its users based on their preferences.\n\n3.  **Shopping:** Retail corporations largely aim to maximize revenue by\n    making it easy for people to make purchases. Recommendation systems\n    on online shopping platforms provide a mechanism for curating\n    specific items based on an individual's previous purchases (or even\n    browsing history) to make shoppers aware of items they may like and,\n    therefore, purchase.\n\nTwo key models used in pairwise sampling are the Thurstonian and Bradley-Terry models [@cattelan2012]. The Thurstonian model assumes each item $i$ has a true score $u_i$ following a normal distribution. The difference $d_{ij} = u_i - u_j$ is also normally distributed. The probability that item $i$ is preferred over item $j$ is given by $P(i \\succ j) = \\Phi \\left( \\frac{u_i - u_j}{\\sqrt{2\\sigma^2}} \\right)$, where $\\Phi$ is the cumulative normal distribution function. The denominator $\\sqrt{2\\sigma^2}$ is the standard deviation of the difference $d_{ij} = u_i - u_j$ when $u_i$ and $u_j$ are normally distributed with variance $\\sigma^2$[@cattelan2012]. The Bradley-Terry model defines the probability of preference based on latent scores $\\beta_i$ and $\\beta_j$. The probability that item $i$ is preferred over item $j$ is $P(i \\succ j) = \\frac{e^{\\beta_i}}{e^{\\beta_i} + e^{\\beta_j}}$. This model is used to estimate relative strengths or preferences based on latent scores. [@cattelan2012].\n\n::: {#tbl-philosophy}\n  -----------------------------------------------------------------------\n  Application                         Human Preference\n  ----------------------------------- -----------------------------------\n  Computer vision: train a neural     This is how humans process images\n  network to predict bounding boxes   by identifying the position and\n  delineating all instances of dogs   geometry of the things we see in\n  in an image                         them\n\n  Natural language processing: train  Coherent text is itself a\n  a model to generate coherent text   human-created and defined concept,\n                                      and we prefer that any\n                                      synthetically generated text\n                                      matches that of humans\n\n  Computer vision: train a diffusion  Humans prefer that images\n  model to generate realistic images  accurately capture the world as\n  of nature                           observed by humans, and this\n                                      generative model should reflect the\n                                      details that comprise that\n                                      preference\n  -----------------------------------------------------------------------\n\n  : Examples of machine learning tasks and their interpretation as\n  modeling human preferences.\n:::\n-->\n\n<!--\nGame theory provides a mathematical framework for analyzing strategic\ninteractions among rational agents. These models help in understanding\nand predicting human behavior by considering multiple criteria and the\nassociated trade-offs. They enhance the understanding of preferences\nacross multiple criteria and allow for richer and more accurate feedback\nthrough structured comparisons. Game-theory framings capture the\ncomplexity of preferences and interactions in decision-making processes\n[@bhatia2020preference].\n\nThe most popular form of preference elicitation involves pairwise\ncomparisons. Users are asked to choose between two options, such as\nproduct A or product B. This method is used in various applications like\nsearch engines, recommender systems, and interactive robotics. Key\nconcepts include the Von Neumann Winner and the Blackwell Winner. The\nVon Neumann Winner refers to a distribution over objects that beats or\nties every other object in the collection under the expected utility\nassumption. The Blackwell Winner generalizes the Von Neumann Winner for\nmulti-criteria problems using a target set for acceptable payoff vectors\n[@bhatia2020preference].\n\nGame-theory framings provide a framework for preference learning along\nmultiple criteria. These models use tools from vector-valued payoffs in\ngame theory, with Blackwell's approach being a key concept. This\napproach allows for a more comprehensive understanding of preferences by\nconsidering multiple criteria simultaneously [@bhatia2020preference].\n\nIn game-theory framings, pairwise preferences are modeled as random\nvariables. Comparisons between objects along different criteria are\ncaptured in a preference tensor $P$. This tensor models the probability\nthat one object is preferred over another along a specific criterion,\nallowing for a detailed understanding of preferences across multiple\ndimensions [@bhatia2020preference].\n\nThe preference tensor $P$ captures object comparisons along different\ncriteria. It is defined as:\n$$P(i_1, i_2; j) = P(i_1 \\succ i_2 \\text{ along criterion } j)$$ where\n$P(i_2, i_1; j) = 1 - P(i_1, i_2; j)$. These values are aggregated to\nform an overall preference matrix $P_{ov}$ [@bhatia2020preference].\n\nThe Blackwell Winner is defined using a target set $S$ of acceptable\nscore vectors. The goal is to find a distribution $\\pi^*$ such that\n$P(\\pi^*, \\pi) \\in S$ for all $\\pi$. This method minimizes the maximum\ndistance to the target set, providing a robust solution to\nmulti-criteria preference problems [@bhatia2020preference].\n\nThe optimization problem for finding the Blackwell Winner is defined as:\n$$\\pi(P, S, \\|\\cdot\\|) = \\arg \\min_{\\pi \\in \\Delta_d} \\left[ \\max_{\\pi' \\in \\Delta_d} \\rho(P(\\pi, \\pi'), S) \\right]$$\nwhere $\\rho(u, v) = \\|u - v\\|$. This measures the distance to the target\nset, ensuring that the selected distribution is as close as possible to\nthe ideal preference vector [@bhatia2020preference].\n-->\n\n",
    "supporting": [
      "chap3_files/figure-pdf"
    ],
    "filters": []
  }
}