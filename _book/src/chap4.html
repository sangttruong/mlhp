<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>5&nbsp; Aggregation of Preferences – Machine Learning from Human Preferences</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../src/chap5.html" rel="next">
<link href="../src/chap3.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-07ba0ad10f5680c660e360ac31d2f3b6.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark-8b864f0777c60eecff11d75b6b2e1175.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-fa3d1c749edcb96cd5cb7d620f3e5237.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark-6f24586c8b15e78d85e3983c622e3e8a.min.css" rel="prefetch" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script src="../site_libs/quarto-contrib/pseudocode-2.4.1/pseudocode.min.js"></script>
<link href="../site_libs/quarto-contrib/pseudocode-2.4.1/pseudocode.min.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script>
MathJax = {
  loader: {
    load: ['[tex]/boldsymbol']
  },
  tex: {
    tags: "all",
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\\[','\\]']],
    processEscapes: true,
    processEnvironments: true,
    packages: {
      '[+]': ['boldsymbol']
    }
  }
};
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../src/chap4.html"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Aggregation of Preferences</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Machine Learning from Human Preferences</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="https://github.com/sangttruong/mlhp" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="../Machine-Learning-from-Human-Preferences.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../src/chap1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Models of Preferences and Decisions</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../src/chap2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Active Learning of Preference Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../src/chap3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Alignment of Policy with Preferences</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../src/chap4.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Aggregation of Preferences</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../src/chap5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Human Values and AI Alignment</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../src/ack.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Acknowledgments</span></a>
  </div>
</li>
    </ul>
    </div>
<div class="quarto-sidebar-footer"><div class="sidebar-footer-item">
<p>license.qmd</p>
</div></div></nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#sec-choices-aggregation" id="toc-sec-choices-aggregation" class="nav-link active" data-scroll-target="#sec-choices-aggregation"><span class="header-section-number">5.1</span> Social Choice Theory</a></li>
  <li><a href="#single-item-auctions" id="toc-single-item-auctions" class="nav-link" data-scroll-target="#single-item-auctions"><span class="header-section-number">5.2</span> Auction Theory</a></li>
  <li><a href="#incentive-compatible-online-learning" id="toc-incentive-compatible-online-learning" class="nav-link" data-scroll-target="#incentive-compatible-online-learning"><span class="header-section-number">5.3</span> Incentive-Compatible Online Learning</a></li>
  <li><a href="#mutual-information-paradigm" id="toc-mutual-information-paradigm" class="nav-link" data-scroll-target="#mutual-information-paradigm"><span class="header-section-number">5.4</span> Mutual Information Paradigm</a></li>
  <li><a href="#bibliography" id="toc-bibliography" class="nav-link" data-scroll-target="#bibliography">References</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/sangttruong/mlhp/blob/main/src/chap4.qmd" class="toc-action"><i class="bi bi-github"></i>View source</a></li><li><a href="https://github.com/sangttruong/mlhp/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Aggregation of Preferences</span></h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="sec-choices-aggregation" class="level2" data-number="5.1">
<h2 data-number="5.1" class="anchored" data-anchor-id="sec-choices-aggregation"><span class="header-section-number">5.1</span> Social Choice Theory</h2>
<p>In many applications, human preferences must be aggregated across multiple individuals to determine a collective decision or ranking. This process is central to social choice theory, which provides a mathematical foundation for preference aggregation. Unlike individual preference modeling, which focuses on understanding how a single person makes decisions, social choice theory addresses the challenge of combining multiple preference profiles into a single, coherent outcome. One of the most widely used approaches to aggregating preferences is voting. A voting rule is a function that maps a set of individual preference rankings to a collective decision. The outcome of a vote is determined by a social choice function (SCF), which selects a winner based on the aggregated preferences. Several voting rules exist, each with different properties:</p>
<ul>
<li>Plurality Rule: Each voter assigns one point to their top choice, and the alternative with the most points wins.</li>
<li>Borda Count: Voters rank all alternatives, and points are assigned based on the position in each ranking.</li>
<li>Single Transferable Vote (STV): Voters rank choices, and rounds of elimination occur until a candidate has a majority.</li>
<li>Condorcet Methods: The Condorcet winner is the item that would win in all pairwise comparisons against other alternatives (if one exists).</li>
</ul>
<p>However, preference aggregation is not always straightforward. The Condorcet Paradox illustrates that no single alternative may be a clear winner due to cycles in majority preferences, violating transitivity. Additionally, different voting rules can yield different winners, highlighting the importance of selecting an appropriate aggregation method. A fundamental result in social choice theory is Arrow’s Impossibility Theorem, which states that when there are three or more alternatives, no voting system can simultaneously satisfy the following fairness criteria:</p>
<ol type="1">
<li>Unanimity (Pareto efficiency): If all individuals prefer one item over another, the group ranking should reflect this.</li>
<li>Independence of Irrelevant Alternatives: The relative ranking of two items should not be influenced by another unrelated item.</li>
<li>Non-dictatorship: No single individual’s preference should always determine the group’s outcome.</li>
</ol>
<p>Arrow’s theorem suggests that every fair aggregation method must compromise on at least one of these desirable properties. Additionally, the Gibbard-Satterthwaite Theorem proves that any deterministic voting rule that selects a single winner is either dictatorial (one person always determines the result) or manipulable (voters can strategically misrepresent their preferences to achieve a better outcome). While manipulation is theoretically possible, certain voting rules, such as STV, introduce computational complexity that makes strategic voting impractical in real-world scenarios.</p>
<p>Preference aggregation is also critical in RLHF, where human judgments guide model training. Aggregating human preferences in RLHF faces challenges similar to traditional voting, such as inconsistencies in preferences and strategic bias. Several approaches address these challenges. For example, Majority Voting simply aggregates by selecting the most preferred response. Weighted Voting adjusts vote weights based on expertise or trustworthiness. Jury Learning is a method that integrates dissenting opinions, ensuring that minority perspectives are not entirely disregarded. Lastly, Social Choice in AI Alignment incorporates diverse human feedback to align AI behavior with a broad spectrum of human values. These approaches highlight the interplay between human preference modeling and machine learning. Designing aggregation mechanisms that reflect collective human values is an ongoing research challenge. While traditional social choice methods focus on aggregation, recent work in pluralistic alignment suggests alternative frameworks that preserve the diversity of human preferences rather than collapsing them into a single decision. Pluralistic AI systems aim to:</p>
<ol type="1">
<li>Present a spectrum of reasonable responses instead of forcing a single choice.</li>
<li>Allow steering towards specific perspectives while maintaining fairness.</li>
<li>Ensure distributional pluralism, calibrating AI systems to diverse human viewpoints.</li>
</ol>
<p>This perspective is particularly relevant in generative AI, where models trained on aggregated preferences may fail to capture the nuances of diverse human values. Aggregating human preferences is a complex task influenced by mathematical constraints and strategic considerations. Voting-based methods provide well-studied mechanisms for aggregation, but they face fundamental limitations, as Arrow’s and Gibbard-Satterthwaite’s theorems outlined. Beyond traditional aggregation, emerging approaches in RL and AI alignment seek to balance fairness, robustness, and pluralism. As machine learning systems increasingly interact with human preferences, designing aggregation frameworks that capture the richness of human decision-making remains an active and critical area of research.</p>
</section>
<section id="single-item-auctions" class="level2" data-number="5.2">
<h2 data-number="5.2" class="anchored" data-anchor-id="single-item-auctions"><span class="header-section-number">5.2</span> Auction Theory</h2>
<p>The first problem within auction theory we will consider is the <em>single-item auction</em>. The premise of this problem is that there is a single item to sell, <span class="math inline">\(n\)</span> bidders (with unknown private valuations of the item <span class="math inline">\(v_1\)</span>, ..., <span class="math inline">\(v_n\)</span>). The bidder’s individual objective is to maximize utility: the value <span class="math inline">\(v_i\)</span> of the item subtracted by the price paid for the item. The auction procedure is standard in the sense that bids are solicited and the highest bid will win the auction. While the objective of the individual bidder is clear, there could be a plethora of different objectives for the auction as a whole. One option could be to maximize social surplus, meaning the goal is to maximize the value of the winner. Another objective could be to maximize seller profit which is the payment of the winner. For simplicity, we can focus on the first objective where the goal is to maximize social surplus. If we want to maximize social surplus it turns out that a great way to do this is the “second-price auction”.</p>
<p>In the second-price auction, we will operate under slightly different conditions. In the second-price auction we (1) solicit sealed bids, (2) have the winner be the highest bidder, and (3) charger winner the second-highest bid price. As an example, if the solicited bids are <span class="math inline">\(b = (2, 6, 4, 1)\)</span> the winner will be that who bid <span class="math inline">\(6\)</span>, but will pay a price of <span class="math inline">\(4\)</span>. From here, we can do some equilibrium analysis to try and learn what the optimal bidding strategy is for each bidder. Let the amount bidder <span class="math inline">\(i\)</span> bids to be <span class="math inline">\(b_i\)</span>, so we have bids <span class="math inline">\(b_1, b_2, ..., b_n\)</span>. How much should bidder <span class="math inline">\(i\)</span> bid? To analyze this, let us define <span class="math inline">\(t_i = max_{j \neq i} b_j\)</span> which represents the max of the bids that is not from bidder <span class="math inline">\(i\)</span>. There are now two cases to consider: if <span class="math inline">\(b_i\)</span> &gt; <span class="math inline">\(t_i\)</span> and if <span class="math inline">\(b_i\)</span> &lt; <span class="math inline">\(t_i\)</span>. In the first case the bidder <span class="math inline">\(i\)</span> wins, and if the bidder bid <span class="math inline">\(b_i = v_i\)</span>, they are guaranteed to have a positive return on bid. In the other case, they lose the bid and the net loss is 0 because they don’t have to pay. From this we can conclude that bidder <span class="math inline">\(i\)</span>’s dominant strategy is to just bid <span class="math inline">\(b_i = v_i\)</span>. Rigorously proving this is a little bit trickier, but it was shown from Vickrey in 1961 [cite] that truthful bidding is the dominant strategy in second-price auctions. A corollary of this is that we are maximizing social surplus since bids are values and the winner is the bidder with highest valuation.</p>
<p>If we want to look at things from the perspective of a seller trying to maximize their profit we need to treat the bidder’s bids as uniform random variables. Consider the example scenario where we have two bidders each bidding uniformly between 0 and 1. What is the seller’s expected profit? (in this case profit and revenue for the seller are the same because we assume the seller throws away the item if it doesn’t sell/has no valuation for it). From there the question now becomes, can we get more expected profit from the seller’s perspective? It turns out there is a design where we can add a reserve price of <span class="math inline">\(r\)</span> to the second-price auction. The way this works is we can (1) Insert seller-bid at <span class="math inline">\(r\)</span>, (2) solicit bids, (3) pick the highest bidder, and 3) charge the 2nd-highest bid. In effect, this is just the second-price auction but with a bid from the seller as well, at a price of <span class="math inline">\(r\)</span>. A lemma, that we won’t prove here, is that the second-price auction with reserve price <span class="math inline">\(r\)</span> still has a dominant strategy of just being truthful. Let’s now consider what the profit of a second-price auction would be with two bidders that uniformly bid between 0 and 1 – but this time we have a reserve price of <span class="math inline">\(1/2\)</span>. To calculate the expected profit we break down the situation into 3 cases:</p>
<ul>
<li><p>Case 1: <span class="math inline">\(1/2 &gt; v_1 &gt; v_2 \rightarrow 1/4 \text{ probability} \rightarrow  \mathbb{E}[\text{profit}] = 0\)</span></p></li>
<li><p>Case 2: <span class="math inline">\(v_1 &gt; v_2 &gt; 1/2 \rightarrow 1/4 \text{probability} \rightarrow \mathbb{E}[v_2 | \text{case 2}] = 2/3\)</span></p></li>
<li><p>Case 3: <span class="math inline">\(v_1 &gt; 1/2 &gt; v_2 \rightarrow 1/2 \text{ probability} \rightarrow 1/2\)</span></p></li>
</ul>
<p>Why is <span class="math inline">\(E[v2 | case 2] = 2/3\)</span>? If <span class="math inline">\(v_1\)</span> and <span class="math inline">\(v_2\)</span> are greater than <span class="math inline">\(1/2\)</span>, they are evenly spread across the interval, meaning the expectation will be 1/2 + 1/6 = 2/3. Adding up all these cases we get <span class="math inline">\(E[profit] = 5/12\)</span>. It turns out that second-price auctions with reserve actually maximize profit in general (for symmetric bidders)! In the previous section we conclude that second-price auctions with reserve maximize profit for the seller. In order to prove this, we now move to the more general topic of asking how should a monopolist divide good across separate markets. We can make the assumption that the demand model is a concave revenue <span class="math inline">\(R(q)\)</span> in quantity <span class="math inline">\(q\)</span>. Under this assumption, we can just divide supply into <span class="math inline">\(q = q_a + q_b\)</span> such that <span class="math inline">\(R'_a(q_a) = R'_b(q_b)\)</span>. The idea from here is a theorem from Myerson in 1981 that states an optimal action maximizes “marginal revenue”. Consider an example where we have two bidders bidding a uniform value between 0 and 1. Our revenue curve can now be derived from the offering price <span class="math inline">\(V(q) = 1 - q\)</span> like so: <span class="math inline">\(R(q) = qV(q) = q - q^2\)</span>. Taking the derivative gives us the marginal revenue <span class="math inline">\(R'(q) = 1-2q\)</span>. This means two things: 1) we want to sell to bidder <span class="math inline">\(i\)</span> with the highest <span class="math inline">\(R'(q_i)\)</span> and 2) we want to sell to bidder <span class="math inline">\(i\)</span> with value at least <span class="math inline">\(1/2\)</span> (if we want a positive <span class="math inline">\(R'(q_i)\)</span>. But this is just a second-price auction with reserve <span class="math inline">\(1/2\)</span>! This means that for symmetric bidders, a second price with reserve is the optimal auction.</p>
<p>An interesting topic to discuss is what benefits auctions bring to the table as opposed to just standard pricing. Online auctions used to be a lot more popular in the early 2000s and have been completely replaced by standard online pricing, even on sites like e-bay. While auctions are slower and have added inherent complexities, they are actually optimal on paper. Standard pricing on the other is non-optimal; although it is fast and simpler for buyers. There is actually a way to quantify this: for pricing <span class="math inline">\(k\)</span> units, the loss is at most <span class="math inline">\(1 / \sqrt{2\pi k}\)</span> of optimal profit. Let’s consider applications in duopoly platform design. We know that the optimal auction is second-price with reserve, but what happens when we introduce competition between two auction platforms? Some important details related to the revenue of a second-price auction is that a second-price auction with no reserve and n bidders leads to larger revenue having an optimal reserve and n - 1 bidders <span class="citation" data-cites="bulow-klemperer1996">(<a href="#ref-bulow-klemperer1996" role="doc-biblioref">Bulow and Klemperer 1996</a>)</span>. Additionally, with an entry cost, no reserve is the optimal strategy for maximizing revenue <span class="citation" data-cites="mcafee-87">(<a href="#ref-mcafee-87" role="doc-biblioref">McAfee and McMillan 1987</a>)</span>. Let’s consider an example of a competing auction system which is Google ads vs Bing ads. How should an advertiser divide the budget between Google and Bing? They should give the same budget to both companies. What happens if Bing raises their prices? Then, the advertising company moves more of its budget to Google from Bing.</p>
<p>The Bulow-Klemperer theorem demonstrates that increased competition can be more valuable than perfect knowledge of bidders’ valuation distributions. This result provides insight into the potential of simple, prior-independent auctions to approach the performance of optimal auctions. The theorem states that for a single-item auction with bidders’ valuations drawn independently from a regular distribution <span class="math inline">\(F\)</span>. Let <span class="math inline">\(F\)</span> be a regular distribution and <span class="math inline">\(n\)</span> a positive integer. Then: <span id="eq-eq3.64"><span class="math display">\[E_{v_1,\ldots,v_{n+1} \sim F}[\text{Rev(VA)}(n+1 \text{ bidders})] \geq E_{v_1,\ldots,v_n \sim F}[\text{Rev(OPT}_F)(n \text{ bidders})] \tag{5.1}\]</span></span> where VA denotes the Vickrey auction and <span class="math inline">\(\text{OPT}_F\)</span> denotes the optimal auction for <span class="math inline">\(F\)</span>. This shows that running a simple Vickrey auction with one extra bidder outperforms the revenue-optimal auction that requires precise knowledge of the distribution. It suggests that in practice, effort spent on recruiting additional bidders may be more fruitful than fine-tuning auction parameters.</p>
<p>The VCG mechanism is a cornerstone of mechanism design, providing a general solution for welfare maximization in multi-parameter environments. The key result is that in every general mechanism design environment, there is a dominant-strategy incentive-compatible (DSIC) welfare-maximizing mechanism. According to VCG, given bids <span class="math inline">\(b_1, \ldots, b_n\)</span>, where each <span class="math inline">\(b_i\)</span> is indexed by the outcome set <span class="math inline">\(\Omega\)</span>, the allocation rule is <span class="math inline">\(x(b) = \arg \max_{\omega \in \Omega} \sum_{i=1}^n b_i(\omega)\)</span>. The payment rule for each agent <span class="math inline">\(i\)</span> is <span class="math inline">\(p_i(b) = \max_{\omega \in \Omega} \sum_{j \neq i} b_j(\omega) - \sum_{j \neq i} b_j(\omega^*)\)</span> where <span class="math inline">\(\omega^* = x(b)\)</span> is the chosen outcome. The key insight is to charge each agent its “externality” - the welfare loss inflicted on other agents by its presence. This payment rule, coupled with the welfare-maximizing allocation rule, yields a DSIC mechanism. The VCG mechanism can be interpreted as having each agent pay its bid minus a “rebate” equal to the increase in welfare attributable to its presence:</p>
<p><span id="eq-eq3.67"><span class="math display">\[p_i(b) = b_i(\omega^*) - \left[ \sum_{j=1}^n b_j(\omega^*) - \max_{\omega \in \Omega} \sum_{j \neq i} b_j(\omega) \right] \tag{5.2}\]</span></span></p>
<p>While the VCG mechanism provides a theoretical solution for DSIC welfare-maximization in general environments, it can be challenging to implement in practice due to computational and communication complexities.</p>
<p>Combinatorial auctions are an important class of multi-parameter mechanism design problems, with applications ranging from spectrum auctions to airport slot allocation. In a combinatorial auction, there are <span class="math inline">\(n\)</span> bidders and a set <span class="math inline">\(M\)</span> of <span class="math inline">\(m\)</span> items. The outcome set <span class="math inline">\(\Omega\)</span> consists of allocations <span class="math inline">\((S_1, \ldots, S_n)\)</span>, where <span class="math inline">\(S_i\)</span> is the bundle allocated to bidder <span class="math inline">\(i\)</span>. Each bidder <span class="math inline">\(i\)</span> has a private valuation <span class="math inline">\(v_i(S)\)</span> for each bundle <span class="math inline">\(S \subseteq M\)</span>. While the VCG mechanism theoretically solves the welfare-maximization problem, combinatorial auctions face several major challenges in practice. First, each bidder has <span class="math inline">\(2^m - 1\)</span> private parameters, making direct revelation infeasible for even moderate numbers of items. This necessitates the use of indirect mechanisms that elicit information on a “need-to-know” basis. In addition, even when preference elicitation is not an issue, welfare-maximization can be an intractable problem. In practice, approximations are often used, hoping to achieve reasonably good welfare. The VCG mechanism can exhibit bad revenue and incentive properties in combinatorial settings. For example, adding bidders can sometimes decrease revenue to zero, and the mechanism can be vulnerable to collusion and false-name bids. Last but not least, strategic Behavior in Iterative Auctions: Most practical combinatorial auctions are iterative, comprising multiple rounds. This introduces new opportunities for strategic behavior, such as using bids to signal intentions to other bidders. These challenges make combinatorial auctions a rich and complex area of study, requiring careful design to balance theoretical guarantees with practical considerations.</p>
<p>Spectrum auctions represent a complex application of combinatorial auction theory. With n bidders and m non-identical items, each bidder has a private valuation for every possible bundle of items, making it impractical to directly elicit all preferences. This necessitates the use of indirect, iterative mechanisms that query bidders for valuation information on a “need-to-know” basis, sacrificing some of the desirable properties of direct mechanisms like dominant strategy incentive compatibility (DSIC) and full welfare maximization. The fundamental challenge in spectrum auctions lies in the nature of the items being sold. There is a dichotomy between items that are substitutes (where <span class="math inline">\(v(AB) \leq v(A) + v(B))\)</span> and those that are complements (where <span class="math inline">\(v(AB) &gt; v(A) + v(B))\)</span>. Substitute items, such as licenses for the same area with equal-sized frequency ranges, are generally easier to handle. When items are substitutes, welfare maximization is computationally tractable, and the VCG mechanism avoids many undesirable properties. However, complementary items, which arise naturally in spectrum auctions when bidders want adjacent licenses, present significant challenges. Early attempts at spectrum auctions revealed the pitfalls of naive approaches. Sequential auctions, where items are sold one after another, proved problematic as demonstrated by a Swiss auction in 2000. Bidders struggled to bid intelligently without knowing future prices, leading to unpredictable outcomes and potential revenue loss. Similarly, simultaneous sealed-bid auctions, as used in New Zealand in 1990, created difficulties for bidders in coordinating their bids across multiple items, resulting in severely suboptimal outcomes.</p>
<p>The Simultaneous Ascending Auction (SAA) emerged as a solution to these issues and has formed the basis of most spectrum auctions over the past two decades. In an SAA, multiple items are auctioned simultaneously in rounds, with bidders placing bids on any subset of items subject to an activity rule. This format facilitates price discovery, allowing bidders to adjust their strategies as they learn about others’ valuations. It also allows bidders to determine valuations on a need-to-know basis, reducing the cognitive burden compared to direct-revelation auctions. Despite its advantages, the SAA is not without vulnerabilities. Demand reduction, where bidders strategically reduce their demand to lower prices, can lead to inefficient outcomes even when items are substitutes. The exposure problem arises with complementary items, where bidders risk winning only a subset of desired items at unfavorable prices. These issues highlight the ongoing challenges in designing effective spectrum auctions, balancing theoretical guarantees with practical considerations.</p>
<p>Case study: Classroom Peer Grading. This section discusses work by Jason Hartline, Yingkai Li, Liren Shan, and Yifan Wu at Northwestern University, where researchers examined mechanism design for the classroom, specifically in terms of the optimization of scoring rules. They explored peer grading in the classroom and how to construct a peer grading system that optimizes the objectives for each stakeholder in the system, including those being graded, the peer graders, the TAs of the class, and the professor. Firstly, let’s think of the classroom like a computer. We can think of students as local optimizers; their incentive is to minimize the amount of work they need to do and maximize the grades that they receive. The graders are imprecise operators, which means that there is some uncertainty in their ability to grade the work completed by the students. The syllabus can be thought of as the rules that map the actions of the students to the grade they end up receiving in the class. Our overall goals for this classroom based on these definitions is to minimize work, maximize learning, and fairly assess the students for the work that they do <span class="citation" data-cites="jasonH2020">(<a href="#ref-jasonH2020" role="doc-biblioref">Hartline et al. 2020</a>)</span>. One basic question that we can examine, is what is the best syllabus that maximizes our objectives for our classroom design. Some components of this could include grading randomized exams, grading with partial credit, group projects, and finally, peer grading, which is the component that we will be taking a deeper dive into. The general situation of the peer grading problem is that proper scoring rules make peer grades horrible <span class="citation" data-cites="jasonH2020">(<a href="#ref-jasonH2020" role="doc-biblioref">Hartline et al. 2020</a>)</span>. So we want to be able to optimize scoring rules and make sure that we are optimizing each component of the peer grading pipeline.</p>
<p>The main algorithms focused on in this peer grading design paper were matching peers and TAs to submissions and the grading of those submissions from the TAs and the peer reviews <span class="citation" data-cites="jasonH2020">(<a href="#ref-jasonH2020" role="doc-biblioref">Hartline et al. 2020</a>)</span>. There are quite a number of advantages to peer grading including that peers are able to learn from reviewing other people’s work, it reduces the work for the teacher, and improves the turnaround time for assignment feedback (which are all part of our overarching goals for our mechanism design for the classroom). But, it is also important to acknowledge the potential disadvantages of the peer grading system: it is possible that the peer graders present inaccurate grades and there is student unrest. This presents us with a challenge: being able to incentivize accurate peer reviews.</p>
<p>One problem that we run into, when we use the proper scoring rule to score peer reviews, if the peer graders use the lazy peer strategy, which means that they always report 80<span class="math inline">\(\%\)</span> for their peer reviews, they get graded very well using the proper scoring rule algorithm. In fact, the proper scoring rule says that their peer review is 96<span class="math inline">\(\%\)</span> accurate <span class="citation" data-cites="jasonH2023">(<a href="#ref-jasonH2023" role="doc-biblioref">Hartline et al. 2023</a>)</span>. So how do we incentivize effort in reviews from peer graders? We use a scoring rule that maximizes the difference in score between effort or no effort reviews as indicated by the peer reviewers <span class="citation" data-cites="jasonH2023">(<a href="#ref-jasonH2023" role="doc-biblioref">Hartline et al. 2023</a>)</span>. So overall, the analysis of datasets leads to decision optimizations and, eventually, payoff from those decisions.</p>
<p>In conclusion, scoring rules are essential in being able to understand and analyze data thoroughly, and optimal scoring rules for binary effort allow us to understand the setting independent of the dataset <span class="citation" data-cites="jasonH2023">(<a href="#ref-jasonH2023" role="doc-biblioref">Hartline et al. 2023</a>)</span>.</p>
</section>
<section id="incentive-compatible-online-learning" class="level2" data-number="5.3">
<h2 data-number="5.3" class="anchored" data-anchor-id="incentive-compatible-online-learning"><span class="header-section-number">5.3</span> Incentive-Compatible Online Learning</h2>
<p>To address this problem, we seek to create a model. We first outline the key criteria that our model must achieve. The model revolves around repeated interactions between a planner (the system) and multiple agents (the users). Each agent, upon arrival in the system, is presented with a set of available options to choose from. These options could vary widely depending on the application of the model, such as routes in a transportation network, a selection of hotels in a travel booking system, or even entertainment choices in a streaming service. The <em>interaction process</em> is straightforward but crucial: agents arrive, select an action from the provided options, and then report feedback based on their experience. This feedback is vital as it forms the basis upon which the planner improves and evolves its recommendations. The agents in this model are considered strategic; they aim to maximize their reward based on the information available to them. This aspect of the model acknowledges the real-world scenario where users are typically self-interested and seek to optimize their own outcomes. The <em>planner</em>, on the other hand, has a broader objective. It aims to learn which alternatives are best in a given context and works to maximize the overall welfare of all agents. This involves a complex balancing act: the planner must accurately interpret feedback from a diverse set of agents, each with their own preferences and biases, and use this information to refine and improve the set of options available. The ultimate goal of the planner is to create a dynamic, responsive system that not only caters to the immediate needs of individual agents but also enhances the collective experience over time, leading to a continually improving recommendation ecosystem.</p>
<p>Here, we seek to address the inherent limitations faced by the planner, particularly in scenarios where monetary transfers are not an option, and the only tool at its disposal is the control over the flow of information between agents. This inquiry aims to understand the extent to which these limitations impact the planner’s ability to effectively guide and influence agent behavior. A critical question is whether the planner can successfully induce exploration among agents, especially in the absence of financial incentives. This involves investigating strategies to encourage users to try less obvious or popular options, thus broadening the scope of feedback and enhancing the system’s ability to learn and identify the best alternatives. Another question is understanding the rate at which the planner learns from agent interactions. This encompasses examining how different agent incentives, their willingness to explore, and their feedback impact the speed and efficiency with which the planner can identify optimal recommendations.</p>
<p>The model can be extended in several directions, each raising its own set of questions.</p>
<pre><code>1.  Multiple Agents with Interconnected Payoffs: When multiple agents arrive simultaneously, their choices and payoffs become interconnected, resembling a game. The research question here focuses on how these interdependencies affect individual and collective decision-making.

2.  Planner with Arbitrary Objective Function: Investigating scenarios where the planner operates under an arbitrary objective function, which might not align with maximizing overall welfare or learning the best alternative.

3.  Observed Heterogeneity Among Agents: This involves situations where differences among agents are observable and known, akin to contextual bandits in machine learning. The research question revolves around how these observable traits can be used to tailor recommendations more effectively.

4.  Unobserved Heterogeneity Among Agents: This aspect delves into scenarios where differences among agents are not directly observable, necessitating the use of causal inference techniques to understand and cater to diverse user needs.</code></pre>
<p>In our setup, there is a “planner,” which aims to increase exploration, and many independent “agents,” which will act selfishly (in a way that they believe will maximize their individual reward) <span class="citation" data-cites="mansour2019bayesianincentivecompatiblebanditexploration mansour2021bayesianexplorationincentivizingexploration">(<a href="#ref-mansour2019bayesianincentivecompatiblebanditexploration" role="doc-biblioref">Mansour, Slivkins, and Syrgkanis 2019</a>; <a href="#ref-mansour2021bayesianexplorationincentivizingexploration" role="doc-biblioref">Mansour et al. 2021</a>)</span>. Under our model shown in Figure <a href="#fig-planner-agent" data-reference-type="ref" data-reference="fig-planner-agent">1.1</a>, there are <span class="math inline">\(K\)</span> possible actions that all users can take, and each action has some mean reward <span class="math inline">\(\mu_i \in [0, 1]\)</span>. In addition, there is a common prior belief on each <span class="math inline">\(\mu_i\)</span> across all users.. The <span class="math inline">\(T\)</span> agents, or users, will arrive sequentially. As the <span class="math inline">\(t\)</span>’th user arrives, they are recommended an action <span class="math inline">\(I_t\)</span> by the planner, which they are free to follow or not follow. After taking whichever action they choose, the user experiences some realized reward <span class="math inline">\(r_i \in [0, 1]\)</span>, which is stochastic i.i.d. with mean <span class="math inline">\(\mu_i\)</span>, and reports this reward back to the planner.</p>
<p>So far, the model we have defined is equivalent to a multi-armed bandit model, which we have seen earlier in this chapter (<a href="#4optim" data-reference-type="ref" data-reference="4optim">1</a>). Under this model, well-known results in economics, operations research and computer science show that <span class="math inline">\(O(\sqrt{T})\)</span> regret is achievable <span class="citation" data-cites="russo2015informationtheoreticanalysisthompsonsampling auer_cesa-bianchi_fischer_2002 LAI19854">(<a href="#ref-russo2015informationtheoreticanalysisthompsonsampling" role="doc-biblioref">Russo and Roy 2015</a>; <a href="#ref-auer_cesa-bianchi_fischer_2002" role="doc-biblioref">Auer, Cesa-Bianchi, and Fischer 2002</a>; <a href="#ref-LAI19854" role="doc-biblioref">Lai and Robbins 1985</a>)</span> with algorithms such as Thompson sampling and UCB. However, our agents are strategic and aim to maximize their own rewards. If they observe the rewards gained from actions taken by other previous users, they will simply take the action they believe will yield the highest reward given the previous actions; they would prefer to benefit from exploration done by other users rather than take the risk of exploring themselves. Therefore, exploration on an individual level, which the planner would like to facilitate, is not guaranteed under this paradigm.</p>
<p>In light of this, we also require that our model satisfy <strong>incentive compatibility</strong>, or that taking the action recommended by the planner has an expected utility that is as high as any other action the agent could take. Formally, <span class="math inline">\(\forall i : \, E[\mu_i | I_t = i] \geq E[\mu_{i'} | I_t = i].\)</span> Note that this incentivizes the agents to actually take the actions recommended by the planner; if incentive compatibility is not satisfied, agents would simply ignore the planner and take whatever action they think will lead to the highest reward.</p>
<p>At a high level, the key to achieving incentive compatibility while still creating a policy for the planner that facilitates exploration is information asymmetry. Under this paradigm, the users only have access to their previous recommendations, actions, and rewards, and not to the recommendations, actions, and rewards of other users. Therefore, they are unsure of whether, after other users take certain actions and receive certain rewards, arms that they might have initially considered worse in practice outperform arms that they initially considered better. Only the planner has access to the previous actions and rewards of all users; the user only has access to their own recommendations and overall knowledge of the planner’s policy. The main question we aim to answer for the rest of this section is, given this new constraint of incentive compatibility, is <span class="math inline">\(O(\sqrt{T})\)</span> regret still achievable? We illustrate such an algorithm in the following.</p>
<p>The main result here is a <strong>black-box reduction</strong> algorithm to turn any bandit algorithm into an <em>incentive compatible</em> one, with only a constant increase in Bayesian regret. Since, as mentioned earlier, there are bandit algorithms with <span class="math inline">\(O(\sqrt{T})\)</span> Bayesian regret, black-box reduction will also allow us to get incentive-compatible algorithms with <span class="math inline">\(O(\sqrt{T})\)</span> regret. The idea of black-box reduction will be to simulate <span class="math inline">\(T\)</span> steps of any bandit algorithm in an incentive-compatible way in <span class="math inline">\(c T\)</span> steps. This allows us to design incentive-compatible recommendation systems by using any bandit algorithm and then adapting it. Consider the following setting: there are two possible actions, <span class="math inline">\(A_1\)</span> and <span class="math inline">\(A_2\)</span>. Assume the setting of <strong>deterministic rewards</strong>, where action 1 has reward <span class="math inline">\(\mu_1\)</span> with prior <span class="math inline">\(U[1/3, 1]\)</span> and mean <span class="math inline">\(\mathbb{E}[\mu_1] = 2/3\)</span>, and action 2 has reward <span class="math inline">\(\mu_2\)</span> with prior <span class="math inline">\(U[0, 1]\)</span> and mean <span class="math inline">\(\mathbb{E}[\mu_2] = 1/2\)</span>. Without the planner intervention and with full observability, users would simply always pick <span class="math inline">\(A_1\)</span>, so how can the planner <em>incentivize</em> users to play <span class="math inline">\(A_2\)</span>?</p>
<p>The key insight is going to be to <em>hide exploration in a pool of exploitation</em>. The users are only going to receive a recommendation from the planner, and no other observations. After deterministically recommending the action with the highest expected reward (<span class="math inline">\(A_1\)</span>), the planner will pick one <strong>guinea pig</strong> to recommend the exploratory action of <span class="math inline">\(A_2\)</span>. The users don’t know whether they are the guinea pig, so intuitively, as long as the planner picks guinea pigs uniformly at random and at low enough frequencies, the optimal decision for the users is still to follow the planner’s recommendation, even if it might go against their interest. The planner will pick the user who will be recommended the exploratory action uniformly at random from the <span class="math inline">\(L\)</span> users that come after the first one (which deterministically gets recommended the exploitation action). Under this setting (illustrated in Figure <a href="#fig-deterministic-guinea-pig" data-reference-type="ref" data-reference="fig-deterministic-guinea-pig">1.2</a>), it is optimal for users to always follow the option that is recommended for them. More formally, if <span class="math inline">\(I_t\)</span> is the recommendation that a user receives at time <span class="math inline">\(t\)</span>, then we have that:</p>
<p><span class="math display">\[
\begin{split}
    \mathbb{E}[\mu_1 - \mu_2 | I_t = 2] Pr[I_t = 2] &amp;= \frac{1}{L} (\mu_1 - \mu_2) \quad \text{(Gains if you are the unlucky guinea pig)}\\
    &amp;+ (1 - \frac{1}{L}) \mathbb{E}[\mu_1 - \mu_2 | \mu_1 &lt; \mu_2] \times p[\mu_1 &lt; \mu_2] \quad \text{(Loss if you are not and $\mu_1 &lt; \mu_2$)}\\
    &amp;\leq 0
\end{split}
\]</span></p>
<p>This holds when <span class="math inline">\(L \geq 12\)</span>. It means that the gains from not taking the recommended action are <em>negative</em>, which implies that users should always take the recommendation. So far we have considered the case where rewards are deterministic, but what about <strong>stochastic rewards</strong>? We are now going to consider the case where rewards are independent and identically distributed from some distribution, and where each action <span class="math inline">\(A_i\)</span> has some reward distribution <span class="math inline">\(r_i^t \sim D_i, \mathbb{E}[r_i^t] = \mu_i\)</span>. Back to the case where there are only two actions, we are going to adapt the prior algorithm of guinea pig-picking to the stochastic reward setting. Since one reward observation is not enough to fully know <span class="math inline">\(\mu_1\)</span> anymore, we’ll instead observe the outcome of the first action <span class="math inline">\(M\)</span> times to form a strong posterior <span class="math inline">\(\mathbb{E}[\mu_1 | r_1^1, \ldots r_1^M]\)</span>. We can use with stochastic rewards when there are two actions. Similarly, as before, we pick one guinea pig uniformly at random from the next <span class="math inline">\(L\)</span> users and use the reward we get as the exploratory signal.&nbsp;In a very similar manner, we can generalize this algorithm from always having two actions to the general multi-armed bandit problem. Now suppose we have a general multi-armed bandit algorithm <span class="math inline">\(A\)</span>. We will wrap this algorithm around our black box reduction algorithm to make it incentive-compatible. We wrap every decision that <span class="math inline">\(A\)</span> would make by exactly <span class="math inline">\(L-1\)</span> recommendations of the action believed to be the best so far. This guarantees that the expected rewards for the users that are not chosen as guinea pigs are at least as good as <span class="math inline">\(A\)</span>’s reward at phase <span class="math inline">\(n\)</span>.</p>
</section>
<section id="mutual-information-paradigm" class="level2" data-number="5.4">
<h2 data-number="5.4" class="anchored" data-anchor-id="mutual-information-paradigm"><span class="header-section-number">5.4</span> Mutual Information Paradigm</h2>
<p>In this section we discuss an influential new framework for designing peer prediction mechanisms, the Mutual Information Paradigm (MIP) introduced by Kong and Schoenebeck <span class="citation" data-cites="kongschoenebeck2019">(<a href="#ref-kongschoenebeck2019" role="doc-biblioref">Kong and Schoenebeck 2019</a>)</span>. Traditional peer prediction approaches typically rely on scoring rules and correlation between agents’ signals. However, these methods often struggle with issues like uninformed equilibria, where agents can coordinate on uninformative strategies that yield higher payoffs than truth-telling. The core idea is to reward agents based on the mutual information between their report and the reports of other agents. We consider a setting with <span class="math inline">\(n\)</span> agents, each possessing a private signal <span class="math inline">\(\Psi_i\)</span> drawn from some set <span class="math inline">\(\Sigma\)</span>. The mechanism asks each agent to report their signal, which we denote as <span class="math inline">\(\hat{\Psi}_i\)</span>. For each agent <span class="math inline">\(i\)</span>, the mechanism randomly selects a reference agent <span class="math inline">\(j \neq i\)</span>. Agent <span class="math inline">\(i\)</span>’s payment is then calculated as <span class="math inline">\(MI(\hat{\Psi}_i; \hat{\Psi}_j)\)</span> where <span class="math inline">\(MI\)</span> is an information-monotone mutual information measure. An information-monotone <span class="math inline">\(MI\)</span> measure must satisfy the following properties:</p>
<ul>
<li><p><strong>Symmetry</strong>: <span class="math inline">\(MI(X; Y) = MI(Y; X)\)</span>.</p></li>
<li><p><strong>Non-negativity</strong>: <span class="math inline">\(MI(X; Y) \geq 0\)</span>, with equality if and only if <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> are independent.</p></li>
<li><p><strong>Data processing inequality</strong>: For any transition probability <span class="math inline">\(M\)</span>, if <span class="math inline">\(Y\)</span> is independent of <span class="math inline">\(M(X)\)</span> conditioned on <span class="math inline">\(X\)</span>, then <span class="math inline">\(MI(M(X); Y) \leq MI(X; Y)\)</span>.</p></li>
</ul>
<p>Two important families of mutual information measures that satisfy these properties are <span class="math inline">\(f\)</span>-mutual information and Bregman mutual information. The <span class="math inline">\(f\)</span>-mutual information is defined as <span class="math inline">\(MI_f(X; Y) = D_f(U_{X,Y}, V_{X,Y})\)</span>, where <span class="math inline">\(D_f\)</span> is an <span class="math inline">\(f\)</span>-divergence, <span class="math inline">\(U_{X,Y}\)</span> is the joint distribution of <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>, and <span class="math inline">\(V_{X,Y}\)</span> is the product of their marginal distributions. The Bregman mutual information is defined as: <span class="math inline">\(BMI_{PS}(X; Y) = \mathbb{E}_{X} [D{PS}(U_{Y|X}, U_Y)]\)</span>, where <span class="math inline">\(D_{PS}\)</span> is a Bregman divergence based on a proper scoring rule <span class="math inline">\(PS\)</span>, <span class="math inline">\(U_{Y|X}\)</span> is the conditional distribution of <span class="math inline">\(Y\)</span> given <span class="math inline">\(X\)</span>, and <span class="math inline">\(U_Y\)</span> is the marginal distribution of <span class="math inline">\(Y\)</span>. The MIP framework can be applied in both single-question and multi-question settings. In the multi-question setting, the mechanism can estimate the mutual information empirically from multiple questions. In the single-question setting, additional techniques like asking for predictions about other agents’ reports are used to estimate the mutual information. A key theoretical result of the MIP framework is that when the chosen mutual information measure is strictly information-monotone with respect to agents’ priors, the resulting mechanism is both dominantly truthful and strongly truthful. This means that truth-telling is a dominant strategy for each agent and that the truth-telling equilibrium yields strictly higher payoffs than any other non-permutation strategy profile. As research continues to address practical implementation challenges of designing truthful mechanisms, MIP-based approaches have significant potential to improve preference elicitation and aggregation in real-world applications lacking verifiable ground truth.</p>


<!-- -->

</section>
<section id="bibliography" class="level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-auer_cesa-bianchi_fischer_2002" class="csl-entry" role="listitem">
Auer, Peter, Nicolò Cesa-Bianchi, and Paul Fischer. 2002. <span>“Finite-Time Analysis of the Multiarmed Bandit Problem.”</span> <em>Machine Learning</em> 47 (2). <a href="https://doi.org/10.1023/A:1013689704352">https://doi.org/10.1023/A:1013689704352</a>.
</div>
<div id="ref-bulow-klemperer1996" class="csl-entry" role="listitem">
Bulow, Jeremy, and Paul Klemperer. 1996. <span>“Auctions Versus Negotiations.”</span> <em>The American Economic Review</em> 86 (1): 180–94. <a href="http://www.jstor.org/stable/2118262">http://www.jstor.org/stable/2118262</a>.
</div>
<div id="ref-jasonH2020" class="csl-entry" role="listitem">
Hartline, Jason D., Yingkai Li, Liren Shan, and Yifan Wu. 2020. <span>“Optimization of Scoring Rules.”</span> <em>CoRR</em> abs/2007.02905. <a href="https://arxiv.org/abs/2007.02905">https://arxiv.org/abs/2007.02905</a>.
</div>
<div id="ref-jasonH2023" class="csl-entry" role="listitem">
Hartline, Jason D., Liren Shan, Yingkai Li, and Yifan Wu. 2023. <span>“Optimal Scoring Rules for Multi-Dimensional Effort.”</span> In <em>Proceedings of Thirty Sixth Conference on Learning Theory</em>, edited by Gergely Neu and Lorenzo Rosasco, 195:2624–50. Proceedings of Machine Learning Research. PMLR. <a href="https://proceedings.mlr.press/v195/hartline23a.html">https://proceedings.mlr.press/v195/hartline23a.html</a>.
</div>
<div id="ref-kongschoenebeck2019" class="csl-entry" role="listitem">
Kong, Yuqing, and Grant Schoenebeck. 2019. <span>“An Information Theoretic Framework for Designing Information Elicitation Mechanisms That Reward Truth-Telling.”</span> <em>ACM Trans. Econ. Comput.</em> 7 (1). <a href="https://doi.org/10.1145/3296670">https://doi.org/10.1145/3296670</a>.
</div>
<div id="ref-LAI19854" class="csl-entry" role="listitem">
Lai, T. L, and Herbert Robbins. 1985. <span>“Asymptotically Efficient Adaptive Allocation Rules.”</span> <em>Advances in Applied Mathematics</em> 6 (1): 4–22. https://doi.org/<a href="https://doi.org/10.1016/0196-8858(85)90002-8">https://doi.org/10.1016/0196-8858(85)90002-8</a>.
</div>
<div id="ref-mansour2019bayesianincentivecompatiblebanditexploration" class="csl-entry" role="listitem">
Mansour, Yishay, Aleksandrs Slivkins, and Vasilis Syrgkanis. 2019. <span>“Bayesian Incentive-Compatible Bandit Exploration.”</span> <a href="https://arxiv.org/abs/1502.04147">https://arxiv.org/abs/1502.04147</a>.
</div>
<div id="ref-mansour2021bayesianexplorationincentivizingexploration" class="csl-entry" role="listitem">
Mansour, Yishay, Aleksandrs Slivkins, Vasilis Syrgkanis, and Zhiwei Steven Wu. 2021. <span>“Bayesian Exploration: Incentivizing Exploration in Bayesian Games.”</span> <a href="https://arxiv.org/abs/1602.07570">https://arxiv.org/abs/1602.07570</a>.
</div>
<div id="ref-mcafee-87" class="csl-entry" role="listitem">
McAfee, R. Preston, and John McMillan. 1987. <span>“Auctions and Bidding.”</span> <em>Journal of Economic Literature</em> 25 (2): 699–738. <a href="http://www.jstor.org/stable/2726107">http://www.jstor.org/stable/2726107</a>.
</div>
<div id="ref-russo2015informationtheoreticanalysisthompsonsampling" class="csl-entry" role="listitem">
Russo, Daniel, and Benjamin Van Roy. 2015. <span>“An Information-Theoretic Analysis of Thompson Sampling.”</span> <a href="https://arxiv.org/abs/1403.5341">https://arxiv.org/abs/1403.5341</a>.
</div>
</div>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../src/chap3.html" class="pagination-link" aria-label="Alignment of Policy with Preferences">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Alignment of Policy with Preferences</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../src/chap5.html" class="pagination-link" aria-label="Human Values and AI Alignment">
        <span class="nav-page-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Human Values and AI Alignment</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb2" data-shortcodes="false"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">---</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="an">title:</span><span class="co"> Aggregation of Preferences</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="an">format:</span><span class="co"> html</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="an">filters:</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="co">  - pyodide</span></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="an">execute:</span></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="co">  engine: pyodide</span></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="co">  pyodide:</span></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="co">    auto: true</span></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="co">---</span></span>
<span id="cb2-11"><a href="#cb2-11"></a></span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="fu">## Social Choice Theory {#sec-choices-aggregation}</span></span>
<span id="cb2-13"><a href="#cb2-13"></a>In many applications, human preferences must be aggregated across multiple individuals to determine a collective decision or ranking. This process is central to social choice theory, which provides a mathematical foundation for preference aggregation. Unlike individual preference modeling, which focuses on understanding how a single person makes decisions, social choice theory addresses the challenge of combining multiple preference profiles into a single, coherent outcome. One of the most widely used approaches to aggregating preferences is voting. A voting rule is a function that maps a set of individual preference rankings to a collective decision. The outcome of a vote is determined by a social choice function (SCF), which selects a winner based on the aggregated preferences. Several voting rules exist, each with different properties:</span>
<span id="cb2-14"><a href="#cb2-14"></a></span>
<span id="cb2-15"><a href="#cb2-15"></a><span class="ss">- </span>Plurality Rule: Each voter assigns one point to their top choice, and the alternative with the most points wins.</span>
<span id="cb2-16"><a href="#cb2-16"></a><span class="ss">- </span>Borda Count: Voters rank all alternatives, and points are assigned based on the position in each ranking.</span>
<span id="cb2-17"><a href="#cb2-17"></a><span class="ss">- </span>Single Transferable Vote (STV): Voters rank choices, and rounds of elimination occur until a candidate has a majority.</span>
<span id="cb2-18"><a href="#cb2-18"></a><span class="ss">- </span>Condorcet Methods: The Condorcet winner is the item that would win in all pairwise comparisons against other alternatives (if one exists).</span>
<span id="cb2-19"><a href="#cb2-19"></a></span>
<span id="cb2-20"><a href="#cb2-20"></a>However, preference aggregation is not always straightforward. The Condorcet Paradox illustrates that no single alternative may be a clear winner due to cycles in majority preferences, violating transitivity. Additionally, different voting rules can yield different winners, highlighting the importance of selecting an appropriate aggregation method. A fundamental result in social choice theory is Arrow’s Impossibility Theorem, which states that when there are three or more alternatives, no voting system can simultaneously satisfy the following fairness criteria:</span>
<span id="cb2-21"><a href="#cb2-21"></a></span>
<span id="cb2-22"><a href="#cb2-22"></a><span class="ss">1. </span>Unanimity (Pareto efficiency): If all individuals prefer one item over another, the group ranking should reflect this.</span>
<span id="cb2-23"><a href="#cb2-23"></a><span class="ss">2. </span>Independence of Irrelevant Alternatives: The relative ranking of two items should not be influenced by another unrelated item.</span>
<span id="cb2-24"><a href="#cb2-24"></a><span class="ss">3. </span>Non-dictatorship: No single individual's preference should always determine the group's outcome.</span>
<span id="cb2-25"><a href="#cb2-25"></a></span>
<span id="cb2-26"><a href="#cb2-26"></a>Arrow’s theorem suggests that every fair aggregation method must compromise on at least one of these desirable properties. Additionally, the Gibbard-Satterthwaite Theorem proves that any deterministic voting rule that selects a single winner is either dictatorial (one person always determines the result) or manipulable (voters can strategically misrepresent their preferences to achieve a better outcome). While manipulation is theoretically possible, certain voting rules, such as STV, introduce computational complexity that makes strategic voting impractical in real-world scenarios.</span>
<span id="cb2-27"><a href="#cb2-27"></a></span>
<span id="cb2-28"><a href="#cb2-28"></a>Preference aggregation is also critical in RLHF, where human judgments guide model training. Aggregating human preferences in RLHF faces challenges similar to traditional voting, such as inconsistencies in preferences and strategic bias. Several approaches address these challenges. For example, Majority Voting simply aggregates by selecting the most preferred response. Weighted Voting adjusts vote weights based on expertise or trustworthiness. Jury Learning is a method that integrates dissenting opinions, ensuring that minority perspectives are not entirely disregarded. Lastly, Social Choice in AI Alignment incorporates diverse human feedback to align AI behavior with a broad spectrum of human values. These approaches highlight the interplay between human preference modeling and machine learning. Designing aggregation mechanisms that reflect collective human values is an ongoing research challenge. While traditional social choice methods focus on aggregation, recent work in pluralistic alignment suggests alternative frameworks that preserve the diversity of human preferences rather than collapsing them into a single decision. Pluralistic AI systems aim to:</span>
<span id="cb2-29"><a href="#cb2-29"></a></span>
<span id="cb2-30"><a href="#cb2-30"></a><span class="ss">1. </span>Present a spectrum of reasonable responses instead of forcing a single choice.</span>
<span id="cb2-31"><a href="#cb2-31"></a><span class="ss">2. </span>Allow steering towards specific perspectives while maintaining fairness.</span>
<span id="cb2-32"><a href="#cb2-32"></a><span class="ss">3. </span>Ensure distributional pluralism, calibrating AI systems to diverse human viewpoints.</span>
<span id="cb2-33"><a href="#cb2-33"></a></span>
<span id="cb2-34"><a href="#cb2-34"></a>This perspective is particularly relevant in generative AI, where models trained on aggregated preferences may fail to capture the nuances of diverse human values. Aggregating human preferences is a complex task influenced by mathematical constraints and strategic considerations. Voting-based methods provide well-studied mechanisms for aggregation, but they face fundamental limitations, as Arrow’s and Gibbard-Satterthwaite’s theorems outlined. Beyond traditional aggregation, emerging approaches in RL and AI alignment seek to balance fairness, robustness, and pluralism. As machine learning systems increasingly interact with human preferences, designing aggregation frameworks that capture the richness of human decision-making remains an active and critical area of research.</span>
<span id="cb2-35"><a href="#cb2-35"></a></span>
<span id="cb2-36"><a href="#cb2-36"></a><span class="fu">## Auction Theory {#single-item-auctions}</span></span>
<span id="cb2-37"><a href="#cb2-37"></a></span>
<span id="cb2-38"><a href="#cb2-38"></a>The first problem within auction theory we will consider is the *single-item auction*. The premise of this problem is that there is a single item to sell, $n$ bidders (with unknown private valuations of the item $v_1$, <span class="sc">\.</span>.., $v_n$). The bidder's individual objective is to maximize utility: the value $v_i$ of the item subtracted by the price paid for the item. The auction procedure is standard in the sense that bids are solicited and the highest bid will win the auction. While the objective of the individual bidder is clear, there could be a plethora of different objectives for the auction as a whole. One option could be to maximize social surplus, meaning the goal is to maximize the value of the winner. Another objective could be to maximize seller profit which is the payment of the winner. For simplicity, we can focus on the first objective where the goal is to maximize social surplus. If we want to maximize social surplus it turns out that a great way to do this is the "second-price auction".</span>
<span id="cb2-39"><a href="#cb2-39"></a></span>
<span id="cb2-40"><a href="#cb2-40"></a>In the second-price auction, we will operate under slightly different conditions. In the second-price auction we (1) solicit sealed bids, (2) have the winner be the highest bidder, and (3) charger winner the second-highest bid price. As an example, if the solicited bids are $b = (2, 6, 4, 1)$ the winner will be that who bid $6$, but will pay a price of $4$. From here, we can do some equilibrium analysis to try and learn what the optimal bidding strategy is for each bidder. Let the amount bidder $i$ bids to be $b_i$, so we have bids $b_1, b_2, ..., b_n$. How much should bidder $i$ bid? To analyze this, let us define $t_i = max_{j \neq i} b_j$ which represents the max of the bids that is not from bidder $i$. There are now two cases to consider: if $b_i$ <span class="sc">\&gt;</span> $t_i$ and if $b_i$ <span class="sc">\&lt;</span> $t_i$. In the first case the bidder $i$ wins, and if the bidder bid $b_i = v_i$, they are guaranteed to have a positive return on bid. In the other case, they lose the bid and the net loss is 0 because they don't have to pay. From this we can conclude that bidder $i$'s dominant strategy is to just bid $b_i = v_i$. Rigorously proving this is a little bit trickier, but it was shown from Vickrey in 1961 <span class="sc">\[</span>cite<span class="sc">\]</span> that truthful bidding is the dominant strategy in second-price auctions. A corollary of this is that we are maximizing social surplus since bids are values and the winner is the bidder with highest valuation.</span>
<span id="cb2-41"><a href="#cb2-41"></a></span>
<span id="cb2-42"><a href="#cb2-42"></a>If we want to look at things from the perspective of a seller trying to maximize their profit we need to treat the bidder's bids as uniform random variables. Consider the example scenario where we have two bidders each bidding uniformly between 0 and 1. What is the seller's expected profit? (in this case profit and revenue for the seller are the same because we assume the seller throws away the item if it doesn't sell/has no valuation for it). From there the question now becomes, can we get more expected profit from the seller's perspective? It turns out there is a design where we can add a reserve price of $r$ to the second-price auction. The way this works is we can (1) Insert seller-bid at $r$, (2) solicit bids, (3) pick the highest bidder, and 3) charge the 2nd-highest bid. In effect, this is just the second-price auction but with a bid from the seller as well, at a price of $r$. A lemma, that we won't prove here, is that the second-price auction with reserve price $r$ still has a dominant strategy of just being truthful. Let's now consider what the profit of a second-price auction would be with two bidders that uniformly bid between 0 and 1 -- but this time we have a reserve price of $1/2$. To calculate the expected profit we break down the situation into 3 cases:</span>
<span id="cb2-43"><a href="#cb2-43"></a></span>
<span id="cb2-44"><a href="#cb2-44"></a><span class="ss">-   </span>Case 1: $1/2 &gt; v_1 &gt; v_2 \rightarrow 1/4 \text{ probability} \rightarrow  \mathbb{E}<span class="co">[</span><span class="ot">\text{profit}</span><span class="co">]</span> = 0$</span>
<span id="cb2-45"><a href="#cb2-45"></a></span>
<span id="cb2-46"><a href="#cb2-46"></a><span class="ss">-   </span>Case 2: $v_1 &gt; v_2 &gt; 1/2 \rightarrow 1/4 \text{probability} \rightarrow \mathbb{E}<span class="co">[</span><span class="ot">v_2 | \text{case 2}</span><span class="co">]</span> = 2/3$</span>
<span id="cb2-47"><a href="#cb2-47"></a></span>
<span id="cb2-48"><a href="#cb2-48"></a><span class="ss">-   </span>Case 3: $v_1 &gt; 1/2 &gt; v_2 \rightarrow 1/2 \text{ probability} \rightarrow 1/2$</span>
<span id="cb2-49"><a href="#cb2-49"></a></span>
<span id="cb2-50"><a href="#cb2-50"></a>Why is $E<span class="co">[</span><span class="ot">v2 | case 2</span><span class="co">]</span> = 2/3$? If $v_1$ and $v_2$ are greater than $1/2$, they are evenly spread across the interval, meaning the expectation will be 1/2 + 1/6 = 2/3. Adding up all these cases we get $E<span class="co">[</span><span class="ot">profit</span><span class="co">]</span> = 5/12$. It turns out that second-price auctions with reserve actually maximize profit in general (for symmetric bidders)! In the previous section we conclude that second-price auctions with reserve maximize profit for the seller. In order to prove this, we now move to the more general topic of asking how should a monopolist divide good across separate markets. We can make the assumption that the demand model is a concave revenue $R(q)$ in quantity $q$. Under this assumption, we can just divide supply into $q = q_a + q_b$ such that $R'_a(q_a) = R'_b(q_b)$. The idea from here is a theorem from Myerson in 1981 that states an optimal action maximizes "marginal revenue". Consider an example where we have two bidders bidding a uniform value between 0 and 1. Our revenue curve can now be derived from the offering price $V(q) = 1 - q$ like so: $R(q) = qV(q) = q - q^2$. Taking the derivative gives us the marginal revenue $R'(q) = 1-2q$. This means two things: 1) we want to sell to bidder $i$ with the highest $R'(q_i)$ and 2) we want to sell to bidder $i$ with value at least $1/2$ (if we want a positive $R'(q_i)$. But this is just a second-price auction with reserve $1/2$! This means that for symmetric bidders, a second price with reserve is the optimal auction.</span>
<span id="cb2-51"><a href="#cb2-51"></a></span>
<span id="cb2-52"><a href="#cb2-52"></a>An interesting topic to discuss is what benefits auctions bring to the table as opposed to just standard pricing. Online auctions used to be a lot more popular in the early 2000s and have been completely replaced by standard online pricing, even on sites like e-bay. While auctions are slower and have added inherent complexities, they are actually optimal on paper. Standard pricing on the other is non-optimal; although it is fast and simpler for buyers. There is actually a way to quantify this: for pricing $k$ units, the loss is at most $1 / \sqrt{2\pi k}$ of optimal profit. Let's consider applications in duopoly platform design. We know that the optimal auction is second-price with reserve, but what happens when we introduce competition between two auction platforms? Some important details related to the revenue of a second-price auction is that a second-price auction with no reserve and n bidders leads to larger revenue having an optimal reserve and n - 1 bidders <span class="co">[</span><span class="ot">@bulow-klemperer1996</span><span class="co">]</span>. Additionally, with an entry cost, no reserve is the optimal strategy for maximizing revenue  <span class="co">[</span><span class="ot">@mcafee-87</span><span class="co">]</span>. Let's consider an example of a competing auction system which is Google ads vs Bing ads. How should an advertiser divide the budget between Google and Bing? They should give the same budget to both companies. What happens if Bing raises their prices? Then, the advertising company moves more of its budget to Google from Bing.</span>
<span id="cb2-53"><a href="#cb2-53"></a></span>
<span id="cb2-54"><a href="#cb2-54"></a>The Bulow-Klemperer theorem demonstrates that increased competition can be more valuable than perfect knowledge of bidders' valuation distributions. This result provides insight into the potential of simple, prior-independent auctions to approach the performance of optimal auctions. The theorem states that for a single-item auction with bidders' valuations drawn independently from a regular distribution $F$. Let $F$ be a regular distribution and $n$ a positive integer. Then:</span>
<span id="cb2-55"><a href="#cb2-55"></a>$$E_{v_1,\ldots,v_{n+1} \sim F}<span class="co">[</span><span class="ot">\text{Rev(VA)}(n+1 \text{ bidders})</span><span class="co">]</span> \geq E_{v_1,\ldots,v_n \sim F}<span class="co">[</span><span class="ot">\text{Rev(OPT}_F)(n \text{ bidders})</span><span class="co">]</span>$$  {#eq-eq3.64}</span>
<span id="cb2-56"><a href="#cb2-56"></a>where VA denotes the Vickrey auction and $\text{OPT}_F$ denotes the</span>
<span id="cb2-57"><a href="#cb2-57"></a>optimal auction for $F$. This shows that running a simple Vickrey auction with one extra bidder outperforms the revenue-optimal auction that requires precise knowledge of the distribution. It suggests that in practice, effort spent on recruiting additional bidders may be more fruitful than fine-tuning auction parameters.</span>
<span id="cb2-58"><a href="#cb2-58"></a></span>
<span id="cb2-59"><a href="#cb2-59"></a>The VCG mechanism is a cornerstone of mechanism design, providing a general solution for welfare maximization in multi-parameter environments. The key result is that in every general mechanism design environment, there is a dominant-strategy incentive-compatible (DSIC) welfare-maximizing mechanism. According to VCG, given bids $b_1, \ldots, b_n$, where each $b_i$ is indexed by the outcome set $\Omega$, the allocation rule is $x(b) = \arg \max_{\omega \in \Omega} \sum_{i=1}^n b_i(\omega)$. The payment rule for each agent $i$ is $p_i(b) = \max_{\omega \in \Omega} \sum_{j \neq i} b_j(\omega) - \sum_{j \neq i} b_j(\omega^*)$ where $\omega^* = x(b)$ is the chosen outcome. The key insight is to charge each agent its "externality" - the welfare loss inflicted on other agents by its presence. This payment rule, coupled with the welfare-maximizing allocation rule, yields a DSIC mechanism. The VCG mechanism can be interpreted as having each agent pay its bid minus a "rebate" equal to the increase in welfare attributable to its presence:</span>
<span id="cb2-60"><a href="#cb2-60"></a></span>
<span id="cb2-61"><a href="#cb2-61"></a>$$p_i(b) = b_i(\omega^*) - \left[ \sum_{j=1}^n b_j(\omega^*) - \max_{\omega \in \Omega} \sum_{j \neq i} b_j(\omega) \right]$$  {#eq-eq3.67}</span>
<span id="cb2-62"><a href="#cb2-62"></a></span>
<span id="cb2-63"><a href="#cb2-63"></a>While the VCG mechanism provides a theoretical solution for DSIC welfare-maximization in general environments, it can be challenging to implement in practice due to computational and communication complexities.</span>
<span id="cb2-64"><a href="#cb2-64"></a></span>
<span id="cb2-65"><a href="#cb2-65"></a>Combinatorial auctions are an important class of multi-parameter mechanism design problems, with applications ranging from spectrum auctions to airport slot allocation. In a combinatorial auction, there are $n$ bidders and a set $M$ of $m$ items. The outcome set $\Omega$ consists of allocations $(S_1, \ldots, S_n)$, where $S_i$ is the bundle allocated to bidder $i$. Each bidder $i$ has a private valuation $v_i(S)$ for each bundle $S \subseteq M$. While the VCG mechanism theoretically solves the welfare-maximization problem, combinatorial auctions face several major challenges in practice. First, each bidder has $2^m - 1$ private parameters, making direct revelation infeasible for even moderate numbers of items. This necessitates the use of indirect mechanisms that elicit information on a "need-to-know" basis. In addition, even when preference elicitation is not an issue, welfare-maximization can be an intractable problem. In practice, approximations are often used, hoping to achieve reasonably good welfare. The VCG mechanism can exhibit bad revenue and incentive properties in combinatorial settings. For example, adding bidders can sometimes decrease revenue to zero, and the mechanism can be vulnerable to collusion and false-name bids. Last but not least, strategic Behavior in Iterative Auctions: Most practical combinatorial auctions are iterative, comprising multiple rounds. This introduces new opportunities for strategic behavior, such as using bids to signal intentions to other bidders. These challenges make combinatorial auctions a rich and complex area of study, requiring careful design to balance theoretical guarantees with practical considerations.</span>
<span id="cb2-66"><a href="#cb2-66"></a></span>
<span id="cb2-67"><a href="#cb2-67"></a>Spectrum auctions represent a complex application of combinatorial auction theory. With n bidders and m non-identical items, each bidder has a private valuation for every possible bundle of items, making it impractical to directly elicit all preferences. This necessitates the use of indirect, iterative mechanisms that query bidders for valuation information on a "need-to-know" basis, sacrificing some of the desirable properties of direct mechanisms like dominant strategy incentive compatibility (DSIC) and full welfare maximization. The fundamental challenge in spectrum auctions lies in the nature of the items being sold. There is a dichotomy between items that are substitutes (where $v(AB) \leq v(A) + v(B))$ and those that are complements (where $v(AB) &gt; v(A) + v(B))$. Substitute items, such as licenses for the same area with equal-sized frequency ranges, are generally easier to handle. When items are substitutes, welfare maximization is computationally tractable, and the VCG mechanism avoids many undesirable properties. However, complementary items, which arise naturally in spectrum auctions when bidders want adjacent licenses, present significant challenges. Early attempts at spectrum auctions revealed the pitfalls of naive approaches. Sequential auctions, where items are sold one after another, proved problematic as demonstrated by a Swiss auction in 2000. Bidders struggled to bid intelligently without knowing future prices, leading to unpredictable outcomes and potential revenue loss. Similarly, simultaneous sealed-bid auctions, as used in New Zealand in 1990, created difficulties for bidders in coordinating their bids across multiple items, resulting in severely suboptimal outcomes.</span>
<span id="cb2-68"><a href="#cb2-68"></a></span>
<span id="cb2-69"><a href="#cb2-69"></a>The Simultaneous Ascending Auction (SAA) emerged as a solution to these issues and has formed the basis of most spectrum auctions over the past two decades. In an SAA, multiple items are auctioned simultaneously in rounds, with bidders placing bids on any subset of items subject to an activity rule. This format facilitates price discovery, allowing bidders to adjust their strategies as they learn about others' valuations. It also allows bidders to determine valuations on a need-to-know basis, reducing the cognitive burden compared to direct-revelation auctions. Despite its advantages, the SAA is not without vulnerabilities. Demand reduction, where bidders strategically reduce their demand to lower prices, can lead to inefficient outcomes even when items are substitutes. The exposure problem arises with complementary items, where bidders risk winning only a subset of desired items at unfavorable prices. These issues highlight the ongoing challenges in designing effective spectrum auctions, balancing theoretical guarantees with practical considerations.</span>
<span id="cb2-70"><a href="#cb2-70"></a></span>
<span id="cb2-71"><a href="#cb2-71"></a>Case study: Classroom Peer Grading. This section discusses work by Jason Hartline, Yingkai Li, Liren Shan, and Yifan Wu at Northwestern University, where researchers examined mechanism design for the classroom, specifically in terms of the optimization of scoring rules. They explored peer grading in the classroom and how to construct a peer grading system that optimizes the objectives for each stakeholder in the system, including those being graded, the peer graders, the TAs of the class, and the professor. Firstly, let's think of the classroom like a computer. We can think of students as local optimizers; their incentive is to minimize the amount of work they need to do and maximize the grades that they receive. The graders are imprecise operators, which means that there is some uncertainty in their ability to grade the work completed by the students. The syllabus can be thought of as the rules that map the actions of the students to the grade they end up receiving in the class. Our overall goals for this classroom based on these definitions is to minimize work, maximize learning, and fairly assess the students for the work that they do <span class="co">[</span><span class="ot">@jasonH2020</span><span class="co">]</span>. One basic question that we can examine, is what is the best syllabus that maximizes our objectives for our classroom design. Some components of this could include grading randomized exams, grading with partial credit, group projects, and finally, peer grading, which is the component that we will be taking a deeper dive into. The general situation of the peer grading problem is that proper scoring rules make peer grades horrible <span class="co">[</span><span class="ot">@jasonH2020</span><span class="co">]</span>. So we want to be able to optimize scoring rules and make sure that we are optimizing each component of the peer grading pipeline.</span>
<span id="cb2-72"><a href="#cb2-72"></a></span>
<span id="cb2-73"><a href="#cb2-73"></a>The main algorithms focused on in this peer grading design paper were matching peers and TAs to submissions and the grading of those submissions from the TAs and the peer reviews  <span class="co">[</span><span class="ot">@jasonH2020</span><span class="co">]</span>. There are quite a number of advantages to peer grading including that peers are able to learn from reviewing other people's work, it reduces the work for the teacher, and improves the turnaround time for assignment feedback (which are all part of our overarching goals for our mechanism design for the classroom). But, it is also important to acknowledge the potential disadvantages of the peer grading system: it is possible that the peer graders present inaccurate grades and there is student unrest. This presents us with a challenge: being able to incentivize accurate peer reviews.</span>
<span id="cb2-74"><a href="#cb2-74"></a></span>
<span id="cb2-75"><a href="#cb2-75"></a>One problem that we run into, when we use the proper scoring rule to score peer reviews, if the peer graders use the lazy peer strategy, which means that they always report 80$\%$ for their peer reviews, they get graded very well using the proper scoring rule algorithm. In fact, the proper scoring rule says that their peer review is 96$\%$ accurate <span class="co">[</span><span class="ot">@jasonH2023</span><span class="co">]</span>. So how do we incentivize effort in reviews from peer graders? We use a scoring rule that maximizes the difference in score between effort or no effort reviews as indicated by the peer reviewers <span class="co">[</span><span class="ot">@jasonH2023</span><span class="co">]</span>. So overall, the analysis of datasets leads to decision optimizations and, eventually, payoff from those decisions.</span>
<span id="cb2-76"><a href="#cb2-76"></a></span>
<span id="cb2-77"><a href="#cb2-77"></a>In conclusion, scoring rules are essential in being able to understand and analyze data thoroughly, and optimal scoring rules for binary effort allow us to understand the setting independent of the dataset <span class="co">[</span><span class="ot">@jasonH2023</span><span class="co">]</span>.</span>
<span id="cb2-78"><a href="#cb2-78"></a></span>
<span id="cb2-79"><a href="#cb2-79"></a><span class="fu">## Incentive-Compatible Online Learning</span></span>
<span id="cb2-80"><a href="#cb2-80"></a></span>
<span id="cb2-81"><a href="#cb2-81"></a>To address this problem, we seek to create a model. We first outline the key criteria that our model must achieve. The model revolves around repeated interactions between a planner (the system) and multiple agents (the users). Each agent, upon arrival in the system, is presented with a set of available options to choose from. These options could vary widely depending on the application of the model, such as routes in a transportation network, a selection of hotels in a travel booking system, or even entertainment choices in a streaming service. The *interaction process* is straightforward but crucial: agents arrive, select an action from the provided options, and then report feedback based on their experience. This feedback is vital as it forms the basis upon which the planner improves and evolves its recommendations. The agents in this model are considered strategic; they aim to maximize their reward based on the information available to them. This aspect of the model acknowledges the real-world scenario where users are typically self-interested and seek to optimize their own outcomes. The *planner*, on the other hand, has a broader objective. It aims to learn which alternatives are best in a given context and works to maximize the overall welfare of all agents. This involves a complex balancing act: the planner must accurately interpret feedback from a diverse set of agents, each with their own preferences and biases, and use this information to refine and improve the set of options available. The ultimate goal of the planner is to create a dynamic, responsive system that not only caters to the immediate needs of individual agents but also enhances the collective experience over time, leading to a continually improving recommendation ecosystem.</span>
<span id="cb2-82"><a href="#cb2-82"></a></span>
<span id="cb2-83"><a href="#cb2-83"></a>Here, we seek to address the inherent limitations faced by the planner, particularly in scenarios where monetary transfers are not an option, and the only tool at its disposal is the control over the flow of information between agents. This inquiry aims to understand the extent to which these limitations impact the planner's ability to effectively guide and influence agent behavior. A critical question is whether the planner can successfully induce exploration among agents, especially in the absence of financial incentives. This involves investigating strategies to encourage users to try less obvious or popular options, thus broadening the scope of feedback and enhancing the system's ability to learn and identify the best alternatives. Another question is understanding the rate at which the planner learns from agent interactions. This encompasses examining how different agent incentives, their willingness to explore, and their feedback impact the speed and efficiency with which the planner can identify optimal recommendations.</span>
<span id="cb2-84"><a href="#cb2-84"></a></span>
<span id="cb2-85"><a href="#cb2-85"></a>The model can be extended in several directions, each raising its own set of questions.</span>
<span id="cb2-86"><a href="#cb2-86"></a>    </span>
<span id="cb2-87"><a href="#cb2-87"></a><span class="in">    1.  Multiple Agents with Interconnected Payoffs: When multiple agents arrive simultaneously, their choices and payoffs become interconnected, resembling a game. The research question here focuses on how these interdependencies affect individual and collective decision-making.</span></span>
<span id="cb2-88"><a href="#cb2-88"></a></span>
<span id="cb2-89"><a href="#cb2-89"></a><span class="in">    2.  Planner with Arbitrary Objective Function: Investigating scenarios where the planner operates under an arbitrary objective function, which might not align with maximizing overall welfare or learning the best alternative.</span></span>
<span id="cb2-90"><a href="#cb2-90"></a></span>
<span id="cb2-91"><a href="#cb2-91"></a><span class="in">    3.  Observed Heterogeneity Among Agents: This involves situations where differences among agents are observable and known, akin to contextual bandits in machine learning. The research question revolves around how these observable traits can be used to tailor recommendations more effectively.</span></span>
<span id="cb2-92"><a href="#cb2-92"></a></span>
<span id="cb2-93"><a href="#cb2-93"></a><span class="in">    4.  Unobserved Heterogeneity Among Agents: This aspect delves into scenarios where differences among agents are not directly observable, necessitating the use of causal inference techniques to understand and cater to diverse user needs.</span></span>
<span id="cb2-94"><a href="#cb2-94"></a></span>
<span id="cb2-95"><a href="#cb2-95"></a>In our setup, there is a "planner," which aims to increase exploration, and many independent "agents," which will act selfishly (in a way that they believe will maximize their individual reward) <span class="co">[</span><span class="ot">@mansour2019bayesianincentivecompatiblebanditexploration; @mansour2021bayesianexplorationincentivizingexploration</span><span class="co">]</span>. Under our model shown in Figure <span class="co">[</span><span class="ot">1.1</span><span class="co">](#fig-planner-agent)</span>{reference-type="ref" reference="fig-planner-agent"}, there are $K$ possible actions that all users can take, and each action has some mean reward $\mu_i \in <span class="co">[</span><span class="ot">0, 1</span><span class="co">]</span>$. In addition, there is a common prior belief on each $\mu_i$ across all users.. The $T$ agents, or users, will arrive sequentially. As the $t$'th user arrives, they are recommended an action $I_t$ by the planner, which they are free to follow or not follow. After taking whichever action they choose, the user experiences some realized reward $r_i \in <span class="co">[</span><span class="ot">0, 1</span><span class="co">]</span>$, which is stochastic i.i.d. with mean $\mu_i$, and reports this reward back to the planner.</span>
<span id="cb2-96"><a href="#cb2-96"></a></span>
<span id="cb2-97"><a href="#cb2-97"></a>So far, the model we have defined is equivalent to a multi-armed bandit model, which we have seen earlier in this chapter (<span class="co">[</span><span class="ot">1</span><span class="co">](#4optim)</span>{reference-type="ref" reference="4optim"}). Under this model, well-known results in economics, operations research and computer science show that $O(\sqrt{T})$ regret is achievable <span class="co">[</span><span class="ot">@russo2015informationtheoreticanalysisthompsonsampling; @auer_cesa-bianchi_fischer_2002; @LAI19854</span><span class="co">]</span> with algorithms such as Thompson sampling and UCB. However, our agents are strategic and aim to maximize their own rewards. If they observe the rewards gained from actions taken by other previous users, they will simply take the action they believe will yield the highest reward given the previous actions; they would prefer to benefit from exploration done by other users rather than take the risk of exploring themselves. Therefore, exploration on an individual level, which the planner would like to facilitate, is not guaranteed under this paradigm.</span>
<span id="cb2-98"><a href="#cb2-98"></a></span>
<span id="cb2-99"><a href="#cb2-99"></a>In light of this, we also require that our model satisfy **incentive compatibility**, or that taking the action recommended by the planner has an expected utility that is as high as any other action the agent could take. Formally, $\forall i : \, E<span class="co">[</span><span class="ot">\mu_i | I_t = i</span><span class="co">]</span> \geq E<span class="co">[</span><span class="ot">\mu_{i'} | I_t = i</span><span class="co">]</span>.$ Note that this incentivizes the agents to actually take the actions recommended by the planner; if incentive compatibility is not satisfied, agents would simply ignore the planner and take whatever action they think will lead to the highest reward.</span>
<span id="cb2-100"><a href="#cb2-100"></a></span>
<span id="cb2-101"><a href="#cb2-101"></a>At a high level, the key to achieving incentive compatibility while still creating a policy for the planner that facilitates exploration is information asymmetry. Under this paradigm, the users only have access to their previous recommendations, actions, and rewards, and not to the recommendations, actions, and rewards of other users. Therefore, they are unsure of whether, after other users take certain actions and receive certain rewards, arms that they might have initially considered worse in practice outperform arms that they initially considered better. Only the planner has access to the previous actions and rewards of all users; the user only has access to their own recommendations and overall knowledge of the planner's policy. The main question we aim to answer for the rest of this section is, given this new constraint of incentive compatibility, is $O(\sqrt{T})$ regret still achievable? We illustrate such an algorithm in the following.</span>
<span id="cb2-102"><a href="#cb2-102"></a></span>
<span id="cb2-103"><a href="#cb2-103"></a>The main result here is a **black-box reduction** algorithm to turn any bandit algorithm into an *incentive compatible* one, with only a constant increase in Bayesian regret. Since, as mentioned earlier, there are bandit algorithms with $O(\sqrt{T})$ Bayesian regret, black-box reduction will also allow us to get incentive-compatible algorithms with $O(\sqrt{T})$ regret. The idea of black-box reduction will be to simulate $T$ steps of any bandit algorithm in an incentive-compatible way in $c T$ steps. This allows us to design incentive-compatible recommendation systems by using any bandit algorithm and then adapting it. Consider the following setting: there are two possible actions, $A_1$ and $A_2$. Assume the setting of **deterministic rewards**, where action 1 has reward $\mu_1$ with prior $U<span class="co">[</span><span class="ot">1/3, 1</span><span class="co">]</span>$ and mean $\mathbb{E}<span class="co">[</span><span class="ot">\mu_1</span><span class="co">]</span> = 2/3$, and action 2 has reward $\mu_2$ with prior $U<span class="co">[</span><span class="ot">0, 1</span><span class="co">]</span>$ and mean $\mathbb{E}<span class="co">[</span><span class="ot">\mu_2</span><span class="co">]</span> = 1/2$. Without the planner intervention and with full observability, users would simply always pick $A_1$, so how can the planner *incentivize* users to play $A_2$?</span>
<span id="cb2-104"><a href="#cb2-104"></a></span>
<span id="cb2-105"><a href="#cb2-105"></a>The key insight is going to be to *hide exploration in a pool of exploitation*. The users are only going to receive a recommendation from the planner, and no other observations. After deterministically recommending the action with the highest expected reward ($A_1$), the planner will pick one **guinea pig** to recommend the exploratory action of $A_2$. The users don't know whether they are the guinea pig, so intuitively, as long as the planner picks guinea pigs uniformly at random and at low enough frequencies, the optimal decision for the users is still to follow the planner's recommendation, even if it might go against their interest. The planner will pick the user who will be recommended the exploratory action uniformly at random from the $L$ users that come after the first one (which deterministically gets recommended the exploitation action). Under this setting (illustrated in Figure <span class="co">[</span><span class="ot">1.2</span><span class="co">](#fig-deterministic-guinea-pig)</span>{reference-type="ref" reference="fig-deterministic-guinea-pig"}), it is optimal for users to always follow the option that is recommended for them. More formally, if $I_t$ is the recommendation that a user receives at time $t$, then we have that:</span>
<span id="cb2-106"><a href="#cb2-106"></a></span>
<span id="cb2-107"><a href="#cb2-107"></a>$$</span>
<span id="cb2-108"><a href="#cb2-108"></a>\begin{split}</span>
<span id="cb2-109"><a href="#cb2-109"></a>    \mathbb{E}<span class="co">[</span><span class="ot">\mu_1 - \mu_2 | I_t = 2</span><span class="co">]</span> Pr<span class="co">[</span><span class="ot">I_t = 2</span><span class="co">]</span> &amp;= \frac{1}{L} (\mu_1 - \mu_2) \quad \text{(Gains if you are the unlucky guinea pig)}<span class="sc">\\</span></span>
<span id="cb2-110"><a href="#cb2-110"></a>    &amp;+ (1 - \frac{1}{L}) \mathbb{E}<span class="co">[</span><span class="ot">\mu_1 - \mu_2 | \mu_1 &lt; \mu_2</span><span class="co">]</span> \times p<span class="co">[</span><span class="ot">\mu_1 &lt; \mu_2</span><span class="co">]</span> \quad \text{(Loss if you are not and $\mu_1 &lt; \mu_2$)}<span class="sc">\\</span></span>
<span id="cb2-111"><a href="#cb2-111"></a>    &amp;\leq 0</span>
<span id="cb2-112"><a href="#cb2-112"></a>\end{split}</span>
<span id="cb2-113"><a href="#cb2-113"></a>$$</span>
<span id="cb2-114"><a href="#cb2-114"></a></span>
<span id="cb2-115"><a href="#cb2-115"></a>This holds when $L \geq 12$. It means that the gains from not taking the recommended action are *negative*, which implies that users should always take the recommendation. So far we have considered the case where rewards are deterministic, but what about **stochastic rewards**? We are now going to consider the case where rewards are independent and identically distributed from some distribution, and where each action $A_i$ has some reward distribution $r_i^t \sim D_i, \mathbb{E}<span class="co">[</span><span class="ot">r_i^t</span><span class="co">]</span> = \mu_i$. Back to the case where there are only two actions, we are going to adapt the prior algorithm of guinea pig-picking to the stochastic reward setting. Since one reward observation is not enough to fully know $\mu_1$ anymore, we'll instead observe the outcome of the first action $M$ times to form a strong posterior $\mathbb{E}<span class="co">[</span><span class="ot">\mu_1 | r_1^1, \ldots r_1^M</span><span class="co">]</span>$. We can use with stochastic rewards when there are two actions. Similarly, as before, we pick one guinea pig uniformly at random from the next $L$ users and use the reward we get as the exploratory signal.\ In a very similar manner, we can generalize this algorithm from always having two actions to the general multi-armed bandit problem. Now suppose we have a general multi-armed bandit algorithm $A$. We will wrap this algorithm around our black box reduction algorithm to make it incentive-compatible. We wrap every decision that $A$ would make by exactly $L-1$ recommendations of the action believed to be the best so far. This guarantees that the expected rewards for the users that are not chosen as guinea pigs are at least as good as $A$'s reward at phase $n$.</span>
<span id="cb2-116"><a href="#cb2-116"></a></span>
<span id="cb2-117"><a href="#cb2-117"></a><span class="fu">## Mutual Information Paradigm {#mutual-information-paradigm}</span></span>
<span id="cb2-118"><a href="#cb2-118"></a>In this section we discuss an influential new framework for designing peer prediction mechanisms, the Mutual Information Paradigm (MIP) introduced by Kong and Schoenebeck <span class="co">[</span><span class="ot">@kongschoenebeck2019</span><span class="co">]</span>. Traditional peer prediction approaches typically rely on scoring rules and correlation between agents' signals. However, these methods often struggle with issues like uninformed equilibria, where agents can coordinate on uninformative strategies that yield higher payoffs than truth-telling. The core idea is to reward agents based on the mutual information between their report and the reports of other agents. We consider a setting with $n$ agents, each possessing a private signal $\Psi_i$ drawn from some set $\Sigma$. The mechanism asks each agent to report their signal, which we denote as $\hat{\Psi}_i$. For each agent $i$, the mechanism randomly selects a reference agent $j \neq i$. Agent $i$'s payment is then calculated as $MI(\hat{\Psi}_i; \hat{\Psi}_j)$ where $MI$ is an information-monotone mutual information measure. An information-monotone $MI$ measure must satisfy the following properties:</span>
<span id="cb2-119"><a href="#cb2-119"></a></span>
<span id="cb2-120"><a href="#cb2-120"></a><span class="ss">-   </span>**Symmetry**: $MI(X; Y) = MI(Y; X)$.</span>
<span id="cb2-121"><a href="#cb2-121"></a></span>
<span id="cb2-122"><a href="#cb2-122"></a><span class="ss">-   </span>**Non-negativity**: $MI(X; Y) \geq 0$, with equality if and only if $X$ and $Y$ are independent.</span>
<span id="cb2-123"><a href="#cb2-123"></a></span>
<span id="cb2-124"><a href="#cb2-124"></a><span class="ss">-   </span>**Data processing inequality**: For any transition probability $M$, if $Y$ is independent of $M(X)$ conditioned on $X$, then $MI(M(X); Y) \leq MI(X; Y)$.</span>
<span id="cb2-125"><a href="#cb2-125"></a></span>
<span id="cb2-126"><a href="#cb2-126"></a>Two important families of mutual information measures that satisfy these properties are $f$-mutual information and Bregman mutual information. The $f$-mutual information is defined as $MI_f(X; Y) = D_f(U_{X,Y}, V_{X,Y})$, where $D_f$ is an $f$-divergence, $U_{X,Y}$ is the joint distribution of $X$ and $Y$, and $V_{X,Y}$ is the product of their marginal distributions. The Bregman mutual information is defined as: $BMI_{PS}(X; Y) = \mathbb{E}_{X} [D{PS}(U_{Y|X}, U_Y)]$, where $D_{PS}$ is a Bregman divergence based on a proper scoring rule $PS$, $U_{Y|X}$ is the conditional distribution of $Y$ given $X$, and $U_Y$ is the marginal distribution of $Y$. The MIP framework can be applied in both single-question and multi-question settings. In the multi-question setting, the mechanism can estimate the mutual information empirically from multiple questions. In the single-question setting, additional techniques like asking for predictions about other agents' reports are used to estimate the mutual information. A key theoretical result of the MIP framework is that when the chosen mutual information measure is strictly information-monotone with respect to agents' priors, the resulting mechanism is both dominantly truthful and strongly truthful. This means that truth-telling is a dominant strategy for each agent and that the truth-telling equilibrium yields strictly higher payoffs than any other non-permutation strategy profile. As research continues to address practical implementation challenges of designing truthful mechanisms, MIP-based approaches have significant potential to improve preference elicitation and aggregation in real-world applications lacking verifiable ground truth.</span></code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
    <footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/sangttruong/mlhp/blob/main/src/chap4.qmd" class="toc-action"><i class="bi bi-github"></i>View source</a></li><li><a href="https://github.com/sangttruong/mlhp/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div></div></footer><script type="text/javascript">
    (function(d) {
      d.querySelectorAll(".pseudocode-container").forEach(function(el) {
        let pseudocodeOptions = {
          indentSize: el.dataset.indentSize || "1.2em",
          commentDelimiter: el.dataset.commentDelimiter || "//",
          lineNumber: el.dataset.lineNumber === "true" ? true : false,
          lineNumberPunc: el.dataset.lineNumberPunc || ":",
          noEnd: el.dataset.noEnd === "true" ? true : false,
          titlePrefix: el.dataset.captionPrefix || "Algorithm"
        };
        pseudocode.renderElement(el.querySelector(".pseudocode"), pseudocodeOptions);
      });
    })(document);
    (function(d) {
      d.querySelectorAll(".pseudocode-container").forEach(function(el) {
        let captionSpan = el.querySelector(".ps-root > .ps-algorithm > .ps-line > .ps-keyword")
        if (captionSpan !== null) {
          let captionPrefix = el.dataset.captionPrefix + " ";
          let captionNumber = "";
          if (el.dataset.pseudocodeNumber) {
            captionNumber = el.dataset.pseudocodeNumber + " ";
            if (el.dataset.chapterLevel) {
              captionNumber = el.dataset.chapterLevel + "." + captionNumber;
            }
          }
          captionSpan.innerHTML = captionPrefix + captionNumber;
        }
      });
    })(document);
    </script>
  




</body></html>